# Task 2.4.5: Solution Modifiers

## Summary

Implemented SPARQL solution modifiers for query result processing. The executor now supports variable projection, duplicate elimination (DISTINCT/REDUCED), result ordering (ORDER BY), and pagination (OFFSET/LIMIT).

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/executor.ex` - Added solution modifier functions (~360 lines added)
- `test/triple_store/sparql/executor_test.exs` - Added 37 new tests (143 total)

### Core Functions

#### `Executor.project/2`

Variable projection (SELECT):

```elixir
@spec project(Enumerable.t(), [String.t()]) :: binding_stream()
def project(stream, vars)
```

- Retains only specified variables in each binding
- Variables not present in binding are omitted (not set to nil)
- Lazy evaluation via `Stream.map/2`

#### `Executor.distinct/1`

Duplicate elimination (DISTINCT):

```elixir
@spec distinct(Enumerable.t()) :: binding_stream()
def distinct(stream)
```

- Removes duplicate bindings using MapSet tracking
- Preserves first occurrence order
- Uses `Stream.transform/3` for semi-lazy evaluation

#### `Executor.reduced/1`

Relaxed duplicate elimination (REDUCED):

```elixir
@spec reduced(Enumerable.t()) :: binding_stream()
def reduced(stream)
```

- Allows but doesn't require duplicate elimination
- Implemented as DISTINCT for correctness

#### `Executor.order_by/2`

Result ordering (ORDER BY):

```elixir
@spec order_by(Enumerable.t(), [{String.t() | tuple(), :asc | :desc}]) :: binding_stream()
def order_by(stream, comparators)
```

- Sorts bindings by one or more comparators
- Supports ascending (`:asc`) and descending (`:desc`) order
- Implements SPARQL ordering rules:
  - Unbound < Blank nodes < IRIs < Literals
  - Numeric comparison for typed numerics
  - Lexicographic comparison for strings/IRIs
- Materializes stream for sorting (O(n) space)

#### `Executor.slice/3`

Pagination (OFFSET/LIMIT):

```elixir
@spec slice(Enumerable.t(), non_neg_integer(), non_neg_integer() | nil) :: binding_stream()
def slice(stream, offset \\ 0, limit \\ nil)
```

- Skips first `offset` bindings
- Returns at most `limit` bindings
- Fully lazy via `Stream.drop/2` and `Stream.take/2`

#### `Executor.offset/2`

Convenience function for OFFSET only:

```elixir
@spec offset(Enumerable.t(), non_neg_integer()) :: binding_stream()
def offset(stream, n)
```

#### `Executor.limit/2`

Convenience function for LIMIT only:

```elixir
@spec limit(Enumerable.t(), non_neg_integer()) :: binding_stream()
def limit(stream, n)
```

### SPARQL Ordering Rules

The `order_by/2` function implements SPARQL ordering:

| Type | Order | Comparison Method |
|------|-------|-------------------|
| Unbound | First | nil < anything |
| Blank nodes | Second | By identifier string |
| IRIs | Third | Lexicographic by IRI string |
| Literals | Fourth | By value (numeric or lexicographic) |

Numeric literals (xsd:integer, xsd:decimal, xsd:float, xsd:double) are compared numerically rather than lexicographically.

### Key Design Decisions

1. **Lazy Evaluation**: `project/2`, `slice/3`, `offset/2`, `limit/2` are fully lazy
2. **Semi-Lazy Distinct**: Uses `Stream.transform/3` to track seen bindings incrementally
3. **Materialized Order**: `order_by/2` must materialize for sorting
4. **Flexible Comparators**: Supports variable names, variable tuples, and expressions
5. **SPARQL Semantics**: Proper type ordering per SPARQL specification

## Test Coverage

37 new tests covering:

### project/2
1. Projects specified variables
2. Handles empty variable list
3. Handles missing variables in binding
4. Handles RDF term values
5. Preserves order
6. Works with streams

### distinct/1
7. Removes duplicate bindings
8. Preserves first occurrence order
9. Handles empty stream
10. Handles all duplicates
11. Distinguishes different bindings
12. Handles RDF term values

### reduced/1
13. Removes duplicates (same as distinct)

### order_by/2
14. Orders by single variable ascending
15. Orders by single variable descending
16. Orders by multiple variables
17. Orders numeric values correctly
18. Handles nil (unbound) values
19. Handles empty comparator list
20. Handles empty stream
21. Orders IRIs lexicographically
22. Orders with variable tuple syntax

### slice/3
23. Applies offset only
24. Applies limit only
25. Applies both offset and limit
26. Handles offset beyond stream length
27. Handles limit of 0
28. Handles offset 0 and nil limit (returns all)
29. Works with streams

### offset/2
30. Skips first n bindings
31. Offset 0 returns unchanged

### limit/2
32. Takes first n bindings
33. Limit 0 returns empty
34. Limit greater than stream length returns all

### Integration
35. Project + distinct combination
36. Order + slice combination
37. Full pipeline: filter + project + order + slice with BGP

## Usage Examples

```elixir
# Project to specific variables
bindings = [
  %{"x" => 1, "y" => 2, "z" => 3}
]
result = Executor.project(bindings, ["x", "z"]) |> Enum.to_list()
# => [%{"x" => 1, "z" => 3}]

# Remove duplicates
bindings = [%{"x" => 1}, %{"x" => 2}, %{"x" => 1}]
result = Executor.distinct(bindings) |> Enum.to_list()
# => [%{"x" => 1}, %{"x" => 2}]

# Order by variable
bindings = [
  %{"name" => {:literal, :simple, "Carol"}},
  %{"name" => {:literal, :simple, "Alice"}},
  %{"name" => {:literal, :simple, "Bob"}}
]
result = Executor.order_by(bindings, [{"name", :asc}]) |> Enum.to_list()
# => Alice, Bob, Carol

# Order by multiple variables
result = Executor.order_by(bindings, [{"group", :asc}, {"name", :desc}])

# Pagination
bindings = [%{"x" => 1}, %{"x" => 2}, %{"x" => 3}, %{"x" => 4}, %{"x" => 5}]
result = Executor.slice(bindings, 1, 2) |> Enum.to_list()
# => [%{"x" => 2}, %{"x" => 3}]

# Full query pipeline
results = bgp_stream
  |> Executor.filter(filter_expr)
  |> Executor.project(["s", "name"])
  |> Executor.distinct()
  |> Executor.order_by([{"name", :asc}])
  |> Executor.slice(0, 10)
  |> Enum.to_list()
```

## Performance Characteristics

| Function | Time | Space | Notes |
|----------|------|-------|-------|
| project/2 | O(n) | O(1) | Fully lazy |
| distinct/1 | O(n) | O(u) | u = unique bindings |
| reduced/1 | O(n) | O(u) | Same as distinct |
| order_by/2 | O(n log n) | O(n) | Materializes for sort |
| slice/3 | O(offset + limit) | O(1) | Fully lazy |
| offset/2 | O(offset) | O(1) | Fully lazy |
| limit/2 | O(limit) | O(1) | Fully lazy |

## Completed Tasks

- [x] 2.4.5.1 Implement `execute_project(stream, vars)` selecting variables
- [x] 2.4.5.2 Implement `execute_distinct(stream)` removing duplicates
- [x] 2.4.5.3 Implement `execute_order(stream, comparators)` sorting results
- [x] 2.4.5.4 Implement `execute_slice(stream, offset, limit)` pagination

## Next Steps

Task 2.4.6: Result Serialization - Serialize execution results to final output format:
- Implement SELECT result as list of binding maps
- Implement CONSTRUCT result as `RDF.Graph`
- Implement ASK result as boolean
- Implement DESCRIBE result as `RDF.Graph` with CBD
