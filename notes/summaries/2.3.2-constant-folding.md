# Task 2.3.2: Constant Folding Optimization

## Summary

Implemented the constant folding optimization pass that evaluates constant expressions at compile time. This reduces runtime computation by pre-evaluating expressions that contain only literal values and simplifies filters that are always true or always false.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/optimizer.ex` - Extended with constant folding (~400 new lines)
- `test/triple_store/sparql/optimizer_test.exs` - Extended test suite (42 new tests, 67 total)

### Core Functions

#### `Optimizer.fold_constants/1`
Evaluates constant expressions at compile time across an algebra tree.

```elixir
@spec fold_constants(algebra()) :: algebra()
def fold_constants(algebra)
```

#### `Optimizer.optimize/2`
Updated to apply both constant folding and filter push-down:

```elixir
@spec optimize(algebra, keyword()) :: algebra
def optimize(algebra, opts \\ [])

# Options:
# - :push_filters - Enable/disable filter push-down (default: true)
# - :fold_constants - Enable/disable constant folding (default: true)
```

### Optimizations Applied

1. **Arithmetic Folding**
   - Evaluates `1 + 2` → `3`
   - Handles add, subtract, multiply, divide
   - Supports unary minus: `-5`
   - Preserves expressions with variables

2. **Comparison Folding**
   - Evaluates `5 > 3` → `true`
   - Supports all comparison operators: `=`, `>`, `<`, `>=`, `<=`
   - Preserves comparisons with variables

3. **Logical Expression Folding**
   - Short-circuit optimization for AND/OR:
     - `false && anything` → `false`
     - `true || anything` → `true`
     - `true && expr` → `expr`
     - `false || expr` → `expr`
   - Double negation elimination: `NOT(NOT(x))` → `x`
   - Evaluates constant logical expressions

4. **Filter Simplification**
   - Always-true filters are removed: `FILTER(5 > 3)` → pattern only
   - Always-false filters produce empty result: `FILTER(5 < 3)` → `{:bgp, []}`

5. **Conditional Expression Folding**
   - IF with constant condition: `IF(true, 1, 2)` → `1`
   - COALESCE with leading constant: `COALESCE(1, ?x)` → `1`
   - Preserves expressions with variable conditions

6. **Algebra Tree Simplification**
   - Empty join elimination: `JOIN(empty, BGP)` → `empty`
   - Empty union removal: `UNION(empty, BGP)` → `BGP`
   - Empty left-join: `OPTIONAL` with empty left → `empty`
   - Propagates emptiness through nested patterns

### Example Transformations

```
# Before optimization:
Filter(5 > 3, BGP([...]))

# After optimization (filter removed since always true):
BGP([...])

# Before:
Filter(1 > 10, BGP([...]))

# After (pattern replaced with empty since always false):
{:bgp, []}

# Before:
BIND(1 + 2 AS ?y)

# After:
BIND(3 AS ?y)

# Before:
Filter(true AND (?x > 5), BGP(?x))

# After (true && simplified):
Filter(?x > 5, BGP(?x))
```

## Test Coverage

42 new tests covering:
- Constant arithmetic operations
- Constant comparison operations
- Logical expression short-circuiting
- Double negation elimination
- IF expression folding
- COALESCE folding
- Always-true/always-false filter handling
- Join/union empty side simplification
- EXTEND expression folding
- ORDER BY expression folding
- Left-join filter folding
- Integration with parser
- Optimization pipeline (fold + push-down)

## Dependencies

Uses existing modules:
- `TripleStore.SPARQL.Expression` - Expression evaluation and constant detection

## Notes

- Constant folding runs before filter push-down in the optimization pipeline
- Folding is idempotent - running it multiple times produces the same result
- Division by zero and other error expressions are preserved (not folded)
- The optimizer respects variable scoping in COALESCE

## Next Steps

Task 2.3.3: BGP Reordering - Reorder triple patterns based on selectivity:
- Estimate selectivity for each pattern
- Move most selective patterns first
- Consider join dependencies
