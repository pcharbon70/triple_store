# Task 1.4.2: Bulk Load Mode - Summary

## Overview
Implemented bulk loading mode for high-throughput data imports. When `bulk_mode: true` is set, the loader disables per-batch fsync and performs a final WAL flush after completion, providing significant performance improvements for large imports.

## Completed Sub-tasks

### 1.4.2.2: Add :bulk_mode Option to Loader
- Added `bulk_mode: boolean()` to `load_opts` type specification
- Added `@bulk_mode_batch_size 50_000` constant for larger default batches
- Updated `load_triples/5` to accept and process `bulk_mode` option
- Bulk mode propagates `sync: false` to all write operations

### 1.4.2.3: Larger Batches in Bulk Mode
- Modified `resolve_batch_size/1` to use `@bulk_mode_batch_size` (50,000) when bulk mode enabled
- Priority order: explicit `batch_size` > explicit `memory_budget` > bulk mode default > standard default
- Larger batches reduce NIF call overhead and improve throughput

### 1.4.2.4: Final Sync After Bulk Load
- Implemented `flush_wal/2` NIF in Rust (`native/rocksdb_nif/src/lib.rs`)
- Added Elixir wrapper in `TripleStore.Backend.RocksDB.NIF`
- After successful bulk load, calls `NIF.flush_wal(db, true)` to ensure durability
- If flush fails, returns `{:error, {:flush_failed, reason}}`

### 1.4.2.5: Document Bulk Mode Trade-offs
- Added comprehensive documentation to `TripleStore.Loader` moduledoc
- Documented durability trade-offs:
  - Process crash: Data is safe (WAL still written, just not fsync'd)
  - OS/power failure: May lose last few batches written before failure
- Added usage examples and performance guidance

## Implementation Details

### Rust NIF: flush_wal
```rust
#[rustler::nif(schedule = "DirtyCpu")]
fn flush_wal<'a>(
    env: Env<'a>,
    db_ref: ResourceArc<DbRef>,
    sync: bool,
) -> NifResult<Term<'a>> {
    // Calls db.flush_wal(sync) for WAL durability
}
```

### Batch Size Resolution Logic
```elixir
defp resolve_batch_size(opts) do
  bulk_mode? = Keyword.get(opts, :bulk_mode, false)

  case {Keyword.get(opts, :batch_size), Keyword.get(opts, :memory_budget)} do
    {size, _} when not is_nil(size) -> validate_batch_size(size)
    {nil, budget} when not is_nil(budget) -> optimal_batch_size(budget)
    {nil, nil} when bulk_mode? -> @bulk_mode_batch_size  # 50,000
    {nil, nil} -> @default_batch_size  # 10,000
  end
end
```

### Write Options Propagation
- Created `write_opts` map with `sync: not bulk_mode?`
- Propagated through both sequential and parallel loading pipelines
- All batch writes use the configured sync setting

## Files Modified

1. `native/rocksdb_nif/src/lib.rs`
   - Added `flush_failed` atom
   - Implemented `flush_wal/2` NIF function

2. `lib/triple_store/backend/rocksdb/nif.ex`
   - Added `flush_wal/2` function specification and NIF stub

3. `lib/triple_store/loader.ex`
   - Added `bulk_mode` to type specification
   - Added `@bulk_mode_batch_size` constant
   - Added NIF import for `flush_wal`
   - Updated `load_triples/5` with bulk mode logic
   - Updated `resolve_batch_size/1` for bulk mode batch sizing
   - Updated `load_triples_sequential/6` and `load_triples_parallel/8` signatures
   - Updated `process_batch/4` to use write_opts
   - Added comprehensive moduledoc documentation

4. `test/triple_store/loader_test.exs`
   - Added "bulk mode" test suite (7 tests)
   - Added "flush_wal NIF" test suite (2 tests)

## Test Results
All 36 loader tests pass, including:
- Bulk mode with parallel loading
- Bulk mode with sequential loading
- Bulk mode with load_file, load_string, load_stream
- Explicit batch_size override
- flush_wal NIF operations

## Usage Example
```elixir
# Enable bulk mode for large imports
{:ok, count} = Loader.load_file(db, manager, "large_dataset.ttl", bulk_mode: true)

# Bulk mode with custom settings
{:ok, count} = Loader.load_graph(db, manager, graph,
  bulk_mode: true,
  parallel: true,
  stages: 8
)
```
