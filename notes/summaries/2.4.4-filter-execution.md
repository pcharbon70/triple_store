# Task 2.4.4: Filter Execution

## Summary

Implemented SPARQL filter execution for query processing. The executor now supports filtering binding streams with SPARQL expressions, implementing proper three-valued logic (true, false, error) and effective boolean value computation per the SPARQL specification.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/executor.ex` - Added filter execution functions (~290 lines added)
- `test/triple_store/sparql/executor_test.exs` - Added 36 new tests (106 total)

### Core Functions

#### `Executor.filter/2`

Main filter function that removes non-matching bindings:

```elixir
@spec filter(Enumerable.t(), tuple()) :: binding_stream()
def filter(stream, expression)
```

- Evaluates expression against each binding
- Keeps bindings where expression evaluates to true
- Removes bindings where expression evaluates to false or error
- Lazy evaluation via `Stream.filter/2`

#### `Executor.evaluate_filter/2`

Two-valued filter evaluation (for filter context):

```elixir
@spec evaluate_filter(tuple(), binding()) :: boolean()
def evaluate_filter(expression, binding)
```

- Returns `true` if expression evaluates to true (EBV)
- Returns `false` if expression evaluates to false or error
- Implements SPARQL semantics where errors propagate as false

#### `Executor.evaluate_filter_3vl/2`

Three-valued filter evaluation:

```elixir
@spec evaluate_filter_3vl(tuple(), binding()) :: {:ok, boolean()} | :error
def evaluate_filter_3vl(expression, binding)
```

- Returns `{:ok, true}` for true result
- Returns `{:ok, false}` for false result
- Returns `:error` for evaluation errors
- Useful for OPTIONAL semantics and debugging

#### `Executor.filter_all/2`

Conjunctive (AND) filter execution:

```elixir
@spec filter_all(Enumerable.t(), [tuple()]) :: binding_stream()
def filter_all(stream, expressions)
```

- Equivalent to `FILTER(e1 && e2 && e3)`
- Binding passes only if ALL expressions are true
- Empty expression list returns stream unchanged

#### `Executor.filter_any/2`

Disjunctive (OR) filter execution:

```elixir
@spec filter_any(Enumerable.t(), [tuple()]) :: binding_stream()
def filter_any(stream, expressions)
```

- Equivalent to `FILTER(e1 || e2 || e3)`
- Binding passes if ANY expression is true
- Empty expression list returns empty stream

#### `Executor.to_effective_boolean/1`

Effective Boolean Value computation:

```elixir
@spec to_effective_boolean(term()) :: {:ok, boolean()} | :error
def to_effective_boolean(term)
```

- Converts RDF terms to boolean per SPARQL specification
- Handles xsd:boolean, strings, numerics
- Returns `:error` for non-EBV-convertible types

### Expression Evaluation Integration

Filter execution integrates with the existing `TripleStore.SPARQL.Expression` module which provides full expression evaluation for:
- Arithmetic operators (+, -, *, /)
- Comparison operators (=, !=, <, >, <=, >=)
- Logical operators (&&, ||, !)
- Built-in functions (BOUND, STR, LANG, DATATYPE, ISIRI, ISBLANK, ISLITERAL, CONTAINS, REGEX, etc.)

### SPARQL Three-Valued Logic

In SPARQL filters, three-valued logic is used:

| Expression Result | Filter Behavior |
|------------------|-----------------|
| true             | Keep binding    |
| false            | Remove binding  |
| error            | Remove binding  |

This differs from SQL where errors typically raise exceptions. In SPARQL, errors "propagate" gracefully, allowing queries to continue processing.

### Effective Boolean Value (EBV)

SPARQL defines EBV conversion rules:

| Type | EBV Rule |
|------|----------|
| xsd:boolean | true/false as-is |
| xsd:string, simple literal | false if "", true otherwise |
| Numeric (integer, decimal, float, double) | false if 0 or NaN, true otherwise |
| Other types | error |

### Key Design Decisions

1. **Expression Module Reuse**: Leverages existing Expression.evaluate/2 rather than reimplementing
2. **Lazy Evaluation**: Uses `Stream.filter/2` for memory-efficient processing
3. **Two-Valued Default**: `filter/2` uses two-valued logic (common case for FILTER)
4. **Three-Valued Option**: `evaluate_filter_3vl/2` provides explicit error distinction
5. **Conjunctive/Disjunctive Helpers**: `filter_all/2` and `filter_any/2` for compound filters

## Test Coverage

36 new tests covering:

### filter/2
1. Filters bindings where expression is true
2. Removes bindings where expression is false
3. Handles error as false (three-valued logic)
4. Works with empty stream
5. Works with all bindings passing
6. Works with no bindings passing

### evaluate_filter/2
7. Returns true for true expression
8. Returns false for false expression
9. Returns false for error (unbound variable)
10. Handles comparison expressions
11. Handles logical AND expressions
12. Handles logical OR expressions
13. Handles logical NOT expressions

### evaluate_filter_3vl/2
14. Returns {:ok, true} for true
15. Returns {:ok, false} for false
16. Returns :error for evaluation error
17. Distinguishes false from error

### filter_all/2 (Conjunctive Filters)
18. Passes bindings matching all expressions
19. Removes bindings failing any expression
20. Handles empty expression list (pass all)
21. Short-circuits on first false

### filter_any/2 (Disjunctive Filters)
22. Passes bindings matching any expression
23. Removes bindings matching no expressions
24. Handles empty expression list (pass none)
25. Short-circuits on first true

### to_effective_boolean/1
26. Boolean true returns {:ok, true}
27. Boolean false returns {:ok, false}
28. Non-empty string returns {:ok, true}
29. Empty string returns {:ok, false}
30. Non-zero integer returns {:ok, true}
31. Zero integer returns {:ok, false}
32. Named node returns :error (no EBV)

### Built-in Functions
33. BOUND returns true for bound variable
34. BOUND returns false for unbound variable
35. CONTAINS filter works
36. REGEX filter works

## Usage Examples

```elixir
# Basic filter - keep bindings where ?age > 18
xsd_integer = "http://www.w3.org/2001/XMLSchema#integer"
expr = {:greater, {:variable, "age"}, {:literal, :typed, "18", xsd_integer}}
filtered = Executor.filter(bindings, expr) |> Enum.to_list()

# Conjunctive filter - ?age > 18 AND ?age < 65
exprs = [
  {:greater, {:variable, "age"}, {:literal, :typed, "18", xsd_integer}},
  {:less, {:variable, "age"}, {:literal, :typed, "65", xsd_integer}}
]
filtered = Executor.filter_all(bindings, exprs) |> Enum.to_list()

# Disjunctive filter - ?status = "active" OR ?status = "pending"
exprs = [
  {:equal, {:variable, "status"}, {:literal, :simple, "active"}},
  {:equal, {:variable, "status"}, {:literal, :simple, "pending"}}
]
filtered = Executor.filter_any(bindings, exprs) |> Enum.to_list()

# Filter with built-in function - BOUND(?email)
expr = {:bound, {:variable, "email"}}
filtered = Executor.filter(bindings, expr) |> Enum.to_list()

# Filter with REGEX - FILTER(REGEX(?name, "^A"))
expr = {:regex, {:variable, "name"}, {:literal, :simple, "^A"}}
filtered = Executor.filter(bindings, expr) |> Enum.to_list()

# Three-valued evaluation for debugging
case Executor.evaluate_filter_3vl(expr, binding) do
  {:ok, true} -> IO.puts("Passes filter")
  {:ok, false} -> IO.puts("Fails filter")
  :error -> IO.puts("Evaluation error")
end
```

## Performance Characteristics

- **filter/2**: O(n) time, O(1) space - fully lazy
- **filter_all/2**: O(n*k) time where k = number of expressions, O(1) space
- **filter_any/2**: O(n*k) time where k = number of expressions, O(1) space

All filter operations maintain lazy evaluation for memory efficiency.

## Completed Tasks

- [x] 2.4.4.1 Implement `execute_filter(stream, expression)` filtering stream
- [x] 2.4.4.2 Implement expression evaluator for all operators (via Expression module)
- [x] 2.4.4.3 Handle three-valued logic (true, false, error)
- [x] 2.4.4.4 Implement built-in function evaluation (via Expression module)

## Next Steps

Task 2.4.5: Solution Modifiers - Execute projection, ordering, and slicing:
- Implement `execute_project(stream, vars)` selecting variables
- Implement `execute_distinct(stream)` removing duplicates
- Implement `execute_order(stream, comparators)` sorting results
- Implement `execute_slice(stream, offset, limit)` pagination
