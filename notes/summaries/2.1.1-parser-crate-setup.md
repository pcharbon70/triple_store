# Task 2.1.1: Parser Crate Setup - Summary

## Overview

Implemented the SPARQL parser NIF wrapper using the `spargebra` crate from the Oxigraph project. The parser converts SPARQL query strings into an Elixir-native AST representation.

## Files Created

### Native Rust Code

- **`native/sparql_parser_nif/Cargo.toml`** - Crate configuration with dependencies:
  - `rustler = "0.35"` - Elixir NIF framework
  - `spargebra = "0.3"` - SPARQL parser
  - `oxiri = "0.2"` - IRI handling (required for base IRI support)

- **`native/sparql_parser_nif/src/lib.rs`** (~760 lines) - NIF implementation including:
  - `parse_query/1` - Main parsing function
  - `nif_loaded/0` - NIF verification
  - Complete AST conversion for all SPARQL 1.1 features

### Elixir Modules

- **`lib/triple_store/sparql/parser/nif.ex`** - Low-level NIF bindings module
- **`lib/triple_store/sparql/parser.ex`** - High-level parser module with helpers:
  - `parse/1`, `parse!/1` - Parse SPARQL queries
  - `nif_loaded?/0` - Check NIF status
  - `query_type/1`, `select?/1`, `construct?/1`, `ask?/1`, `describe?/1` - Query type inspection
  - `get_pattern/1` - Extract pattern from AST
  - `extract_variables/1` - Extract all variables
  - `extract_bgp_triples/1` - Extract BGP triple patterns

### Tests

- **`test/triple_store/sparql/parser_test.exs`** (55 tests) - Comprehensive test coverage:
  - Basic query parsing (SELECT, CONSTRUCT, ASK, DESCRIBE)
  - FILTER expressions
  - OPTIONAL/LEFT JOIN
  - UNION patterns
  - ORDER BY, LIMIT, OFFSET
  - DISTINCT, REDUCED
  - GROUP BY with aggregates
  - VALUES clauses
  - PREFIX and BASE declarations
  - Property paths (^, /, |, *, +, ?)
  - Subqueries
  - Literal types (string, language-tagged, typed)

## AST Structure

The parser returns nested tuples representing the SPARQL query:

```elixir
{:ok, {:select, [
  {"pattern", {:project,
    {:bgp, [{:triple, {:variable, "s"}, {:variable, "p"}, {:variable, "o"}}]},
    [variable: "s", variable: "p", variable: "o"]}},
  {"dataset", nil},
  {"base_iri", nil}
]}}
```

### Term Types
- `:variable` - `{:variable, "name"}`
- `:named_node` - `{:named_node, "http://..."}`
- `:blank_node` - `{:blank_node, "b0"}`
- `:literal` - `{:literal, :simple | :language_tagged | :typed, value, [lang | type]}`
- `:triple` - `{:triple, subject, predicate, object}`

### Pattern Types
- `:bgp` - Basic Graph Pattern
- `:join` - Pattern join
- `:left_join` - OPTIONAL pattern
- `:union` - UNION pattern
- `:filter` - FILTER expression
- `:extend` - BIND expression
- `:project` - Variable projection
- `:distinct`, `:reduced` - Solution modifiers
- `:slice` - LIMIT/OFFSET
- `:order_by` - ORDER BY
- `:group` - GROUP BY with aggregates
- `:values` - VALUES clause
- `:path` - Property path
- `:graph` - GRAPH clause
- `:service` - SERVICE clause
- `:minus` - MINUS pattern

## Technical Notes

1. **spargebra 0.3.x API**: Uses `spargebra::term` module for term types (not `spargebra::algebra`)
2. **Base IRI**: Handled via `oxiri::Iri<String>` (not `NamedNode`)
3. **AggregateExpression**: Uses `CountSolutions` and `FunctionCall` variants with `AggregateFunction` enum
4. **No Lateral**: spargebra 0.3.x doesn't have `GraphPattern::Lateral` (added in later versions)

## Test Results

```
55 tests, 0 failures
```

All SPARQL 1.1 query forms and features are supported and tested.
