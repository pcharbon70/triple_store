# Task 2.5.1: Query Function

## Summary

Implemented the public SPARQL query interface that integrates the parser, optimizer, and executor into a unified query pipeline. The `TripleStore.SPARQL.Query` module provides the main entry point for executing SPARQL queries with support for all query types (SELECT, ASK, CONSTRUCT, DESCRIBE), timeout protection, query explanation, and optional optimization.

## Implementation Details

### Files Created

- `lib/triple_store/sparql/query.ex` - Public query interface (~470 lines)
- `test/triple_store/sparql/query_test.exs` - Comprehensive tests (23 tests)

### Core Functions

#### `Query.query/2`

Main entry point for executing SPARQL queries:

```elixir
@spec query(context(), String.t()) :: {:ok, query_result()} | {:error, term()}
def query(ctx, sparql)
```

- Parses SPARQL string using Parser NIF
- Optimizes algebra using Optimizer
- Executes against database using Executor
- Returns appropriate result type based on query form

#### `Query.query/3`

Query with options:

```elixir
@spec query(context(), String.t(), query_opts()) ::
        {:ok, query_result() | {:explain, explanation()}} | {:error, term()}
def query(ctx, sparql, opts)
```

Options:
- `:timeout` - Maximum execution time in milliseconds (default: 30000)
- `:explain` - Return query plan without executing (default: false)
- `:optimize` - Enable/disable optimization (default: true)
- `:stats` - Statistics for optimizer (predicate cardinalities)

#### `Query.query!/3`

Raising variant that throws on error:

```elixir
@spec query!(context(), String.t(), query_opts()) :: query_result() | {:explain, explanation()}
def query!(ctx, sparql, opts \\ [])
```

### Query Pipeline

The query pipeline executes in this order:

1. **Parse**: `Parser.parse(sparql)` â†’ AST
2. **Extract**: Extract query type, pattern, and metadata from AST
3. **Optimize**: `Optimizer.optimize(pattern, stats: stats)` (optional)
4. **Execute**: Walk pattern recursively, executing each algebra node
5. **Modify**: Apply solution modifiers (DISTINCT, ORDER BY, LIMIT, OFFSET)
6. **Serialize**: Convert binding stream to appropriate result type

### Pattern Execution

The executor handles these algebra patterns:

| Pattern | Executor Function |
|---------|-------------------|
| `{:bgp, triples}` | `execute_bgp/3` |
| `{:join, left, right}` | `hash_join/2` |
| `{:left_join, left, right, expr}` | `left_join/3` |
| `{:union, left, right}` | `union/2` |
| `{:filter, expr, inner}` | `filter/2` |
| `{:project, inner, vars}` | `project/2` |
| `{:distinct, inner}` | `distinct/1` |
| `{:reduced, inner}` | `reduced/1` |
| `{:slice, inner, offset, limit}` | `slice/3` |
| `{:order_by, inner, conditions}` | `order_by/2` |
| `{:extend, inner, var, expr}` | Stream.map with Expression.evaluate |

### Result Types

| Query Type | Result |
|------------|--------|
| SELECT | `[%{String.t() => term()}]` - List of binding maps |
| ASK | `boolean()` - Whether solutions exist |
| CONSTRUCT | `RDF.Graph.t()` - Graph from template instantiation |
| DESCRIBE | `RDF.Graph.t()` - CBD of described resources |

### Explain Mode

When `explain: true` is passed, returns query analysis:

```elixir
%{
  query_type: :select | :ask | :construct | :describe,
  original_pattern: term(),
  optimized_pattern: term(),
  variables: [String.t()],
  modifiers: %{distinct: boolean(), reduced: boolean(), ...},
  optimizations: %{pattern_changed: boolean()}
}
```

### Timeout Protection

Queries execute in a supervised Task with configurable timeout:

```elixir
task = Task.async(fn -> execute_query(ctx, sparql, opts) end)
case Task.yield(task, timeout) || Task.shutdown(task) do
  {:ok, result} -> result
  nil -> {:error, :timeout}
end
```

Default timeout is 30 seconds.

## Test Coverage

23 tests covering:

### SELECT Queries
1. Simple SELECT query execution
2. SELECT * query (all variables)
3. Empty result for no matches
4. SELECT with FILTER

### ASK Queries
5. Returns true when solutions exist
6. Returns false when no solutions exist
7. Specific resource check

### CONSTRUCT Queries
8. Constructs graph from template
9. Empty graph for no matches

### DESCRIBE Queries
10. Describes resource with CBD

### Query Options
11. Timeout option
12. Explain option returns query plan
13. optimize: false skips optimization

### Error Handling
14. Parse error for invalid SPARQL
15. Error for unsupported query type (UPDATE)

### query!/3
16. Returns result for valid query
17. Raises for invalid query

### Solution Modifiers
18. DISTINCT removes duplicates
19. LIMIT restricts result count
20. OFFSET skips results

### Integration
21. Complex query with multiple patterns (JOIN)
22. Query with UNION
23. Query with OPTIONAL (LEFT JOIN)

## Usage Examples

```elixir
# Execute a SELECT query
{:ok, results} = Query.query(ctx, "SELECT ?name WHERE { ?s foaf:name ?name }")
# => {:ok, [%{"name" => {:literal, :simple, "Alice"}}, ...]}

# Execute an ASK query
{:ok, exists} = Query.query(ctx, "ASK { ?s a foaf:Person }")
# => {:ok, true}

# Execute with timeout
{:ok, results} = Query.query(ctx, sparql, timeout: 5000)

# Get query explanation
{:ok, {:explain, info}} = Query.query(ctx, sparql, explain: true)
# => {:ok, {:explain, %{query_type: :select, variables: ["name"], ...}}}

# Disable optimization
{:ok, results} = Query.query(ctx, sparql, optimize: false)

# Raising variant
results = Query.query!(ctx, "SELECT ?s WHERE { ?s ?p ?o }")
```

## Completed Tasks

- [x] 2.5.1.1 Implement `TripleStore.SPARQL.query(ctx, sparql)` returning results
- [x] 2.5.1.2 Implement `TripleStore.SPARQL.query(ctx, sparql, opts)` with options
- [x] 2.5.1.3 Support timeout option for long-running queries
- [x] 2.5.1.4 Support explain option for query plan inspection

## Next Steps

Task 2.5.2: Streaming Results
- Implement `TripleStore.stream_query(ctx, sparql)` returning Stream
- Support backpressure-aware consumption
- Handle early termination cleanly
