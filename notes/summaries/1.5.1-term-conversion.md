# Task 1.5.1: Term Conversion - Summary

## Overview

Implemented the RDF.ex Adapter layer for term conversion between RDF.ex types and internal dictionary-encoded IDs.

## Files Created

### `lib/triple_store/adapter.ex` (~476 lines)

New adapter module providing clean API for RDF.ex integration:

| Function | Description |
|----------|-------------|
| `from_rdf_iri/2` | Converts RDF.IRI to term ID |
| `from_rdf_bnode/2` | Converts RDF.BlankNode to term ID |
| `from_rdf_literal/2` | Converts RDF.Literal to term ID (inline or dictionary) |
| `term_to_id/2` | Generic term to ID conversion |
| `terms_to_ids/2` | Batch term to ID conversion |
| `to_rdf_iri/2` | Converts term ID back to RDF.IRI |
| `to_rdf_bnode/2` | Converts term ID back to RDF.BlankNode |
| `to_rdf_literal/2` | Converts term ID back to RDF.Literal |
| `id_to_term/2` | Generic ID to term conversion |
| `ids_to_terms/2` | Batch ID to term conversion |
| `lookup_term_id/2` | Read-only term ID lookup |

### `test/triple_store/adapter/term_conversion_test.exs` (54 tests)

Comprehensive test coverage including:
- IRI conversion and roundtrip
- BlankNode conversion and roundtrip
- Dictionary-allocated literals (strings, language-tagged, typed)
- Inline-encoded literals (integer, decimal, datetime)
- Batch conversion operations
- Edge cases (unicode, empty strings, long IRIs, special characters)

## Implementation Details

### Term to ID Conversion

```elixir
# For URIs and blank nodes - use Dictionary Manager
def from_rdf_iri(manager, %RDF.IRI{} = iri) do
  Manager.get_or_create_id(manager, iri)
end

# For literals - check for inline encoding first
def from_rdf_literal(manager, %RDF.Literal{} = literal) do
  if Dictionary.inline_encodable?(literal) do
    encode_inline_literal(literal)
  else
    Manager.get_or_create_id(manager, literal)
  end
end
```

### ID to Term Conversion

```elixir
# Dispatch based on decoded type tag
def id_to_term(db, id) when is_integer(id) and id >= 0 do
  IdToString.lookup_term(db, id)
end

# Type-specific with validation
def to_rdf_iri(db, id) do
  {type, _value} = Dictionary.decode_id(id)
  if type == :uri do
    IdToString.lookup_term(db, id)
  else
    {:error, :type_mismatch}
  end
end
```

### Inline Encoding Support

Numeric types are encoded directly without dictionary lookup:

| Type | Encoding | Range |
|------|----------|-------|
| xsd:integer | Dictionary.encode_integer/1 | [-2^59, 2^59) |
| xsd:decimal | Dictionary.encode_decimal/1 | ~14-15 digits |
| xsd:dateTime | Dictionary.encode_datetime/1 | Millisecond precision |

## Type System

The adapter uses Dictionary.decode_id/1 which returns `{type_atom, value}`:

| Type Atom | Description |
|-----------|-------------|
| `:uri` | IRI/URI resource |
| `:bnode` | Blank node |
| `:literal` | Dictionary-allocated literal |
| `:integer` | Inline-encoded integer |
| `:decimal` | Inline-encoded decimal |
| `:datetime` | Inline-encoded datetime |

## Error Handling

| Return | Meaning |
|--------|---------|
| `{:ok, id}` | Successful conversion |
| `:not_found` | ID not in dictionary |
| `{:error, :type_mismatch}` | ID type doesn't match expected |
| `{:error, :unsupported_term}` | Unknown term type |
| `{:error, :requires_manager}` | Non-inline literal needs Manager |

## Test Results

- **54 new tests** added for term conversion
- **653 total tests** (up from 599)
- **All tests passing**
- **No new Credo issues**

## Architecture Notes

The Adapter provides a clean separation between:
1. **RDF.ex types** - User-facing RDF data structures
2. **Dictionary encoding** - Internal 64-bit ID representation
3. **Storage layer** - RocksDB persistence

This allows the higher-level SPARQL and reasoning layers to work with familiar RDF.ex types while the storage layer operates efficiently on integer IDs.

## Next Task

Task 1.5.2: Triple/Graph Conversion - Build on term conversion to handle full triples and RDF graphs.
