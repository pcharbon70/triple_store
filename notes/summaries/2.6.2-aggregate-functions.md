# Task 2.6.2: Aggregate Functions

## Summary

Task 2.6.2 was already largely implemented in the Expression module. This task verified the existing implementation and added comprehensive tests for edge cases, type coercion, and DISTINCT modifiers.

## Implementation Status

All aggregate functions were already implemented in `lib/triple_store/sparql/expression.ex` via the `evaluate_aggregate/2` function. This function is used by the executor during GROUP BY processing.

### 2.6.2.1: COUNT(*) and COUNT(expr)

**Implementation**: `expression.ex:827-835`

```elixir
def evaluate_aggregate({:count, :star, distinct?}, solutions)
def evaluate_aggregate({:count, expr, distinct?}, solutions)
```

- COUNT(*) counts all solutions
- COUNT(expr) counts non-null values of the expression
- Supports DISTINCT modifier to count unique values

### 2.6.2.2: SUM(expr) with type coercion

**Implementation**: `expression.ex:837-845`

```elixir
def evaluate_aggregate({:sum, expr, distinct?}, solutions)
```

- Sums numeric values from solutions
- Type coercion: integer → decimal → double
- Returns 0 for empty input
- Skips non-numeric values

### 2.6.2.3: AVG(expr) with type coercion

**Implementation**: `expression.ex:848-856`

```elixir
def evaluate_aggregate({:avg, expr, distinct?}, solutions)
```

- Computes average of numeric values
- Always returns decimal type
- Returns 0 for empty input
- Skips non-numeric values

### 2.6.2.4: MIN(expr) and MAX(expr)

**Implementation**: `expression.ex:859-876`

```elixir
def evaluate_aggregate({:min, expr, _distinct?}, solutions)
def evaluate_aggregate({:max, expr, _distinct?}, solutions)
```

- Finds minimum/maximum values using term ordering
- Returns error for empty solutions
- Uses `term_sort_key/1` for SPARQL term comparison

### 2.6.2.5: GROUP_CONCAT(expr; separator=...)

**Implementation**: `expression.ex:879-883`

```elixir
def evaluate_aggregate({{:group_concat, separator}, expr, distinct?}, solutions)
```

- Concatenates string representations of values
- Configurable separator (defaults to space)
- Supports DISTINCT modifier

### 2.6.2.6: SAMPLE(expr)

**Implementation**: `expression.ex:886-894`

```elixir
def evaluate_aggregate({:sample, expr, _distinct?}, solutions)
```

- Returns first matching value from solutions
- Returns error for empty solutions

### 2.6.2.7: DISTINCT modifier

All aggregate functions support the DISTINCT modifier as a boolean flag:
- `{:count, expr, true}` - COUNT(DISTINCT expr)
- `{:sum, expr, true}` - SUM(DISTINCT expr)
- `{:avg, expr, true}` - AVG(DISTINCT expr)
- `{{:group_concat, sep}, expr, true}` - GROUP_CONCAT(DISTINCT expr)

## Files Modified

- `test/triple_store/sparql/expression_test.exs` - Added 10 new tests (112 → 122)

## New Tests Added

| Test | Description |
|------|-------------|
| SAMPLE returns error for empty solutions | Edge case handling |
| SUM with mixed numeric types promotes to decimal | Type coercion |
| SUM with DISTINCT removes duplicates | DISTINCT modifier |
| AVG with DISTINCT removes duplicates | DISTINCT modifier |
| AVG of empty returns 0 | Edge case handling |
| MIN returns error for empty solutions | Edge case handling |
| MAX returns error for empty solutions | Edge case handling |
| GROUP_CONCAT with DISTINCT removes duplicates | DISTINCT modifier |
| COUNT skips unbound variables | Null handling |
| SUM skips non-numeric values | Type safety |

## Helper Functions

The implementation uses these helper functions in Expression module:

| Function | Purpose |
|----------|---------|
| `collect_values/3` | Collects non-null values from solutions |
| `collect_numeric_values/3` | Collects and parses numeric values |
| `promote_numeric_type/2` | Determines result type for mixed numerics |
| `make_numeric/2` | Creates typed numeric literal |
| `term_sort_key/1` | Generates comparable key for term ordering |
| `term_to_string/1` | Converts term to string representation |

## Type Coercion Rules

| Left Type | Right Type | Result |
|-----------|------------|--------|
| integer | integer | integer |
| integer | decimal | decimal |
| integer | float | float |
| integer | double | double |
| decimal | float | float |
| decimal | double | double |
| float | double | double |

## Integration Points

The `evaluate_aggregate/2` function integrates with:

1. **Executor GROUP BY** (`executor.ex:group_by/3`) - Uses aggregates for group computation
2. **Expression Module** - Part of the expression evaluation system
3. **Algebra Module** - `:group` nodes contain aggregate specifications

## Test Summary

| Category | Tests |
|----------|-------|
| COUNT | 4 |
| SUM | 4 |
| AVG | 3 |
| MIN | 2 |
| MAX | 2 |
| GROUP_CONCAT | 3 |
| SAMPLE | 2 |
| Expression type identification | 2 |
| **Total aggregate tests** | **22** |

## Notes

- The aggregate computation logic exists in two places:
  1. `Expression.evaluate_aggregate/2` - For expression-level aggregate evaluation
  2. `Executor.compute_aggregate/2` - For GROUP BY processing

  Both implementations follow the same semantics but serve different purposes in the query pipeline.

- Empty solution handling follows SPARQL 1.1 specification:
  - COUNT returns 0
  - SUM returns 0
  - AVG returns 0
  - MIN/MAX return error
  - SAMPLE returns error
