# Task 2.6.1: Group By Execution

## Summary

Implemented GROUP BY execution for SPARQL queries, including solution partitioning by group keys, implicit grouping when aggregates are used without GROUP BY, and HAVING clause filtering.

## Files Modified

- `lib/triple_store/sparql/executor.ex` - Added GROUP BY execution section (~200 lines)
- `lib/triple_store/sparql/query.ex` - Added `:group` pattern handling
- `test/triple_store/sparql/executor_test.exs` - Added 17 new tests (171 -> 188)

## Implementation Details

### 2.6.1.1: execute_group(stream, group_vars) Partitioning

Added `group_by/3` function that:
- Partitions bindings by extracting group key values from specified variables
- Computes aggregates for each group
- Returns stream of group bindings with aggregate results

```elixir
@spec group_by(Enumerable.t(), [term()], [{term(), aggregate_spec()}]) :: binding_stream()
def group_by(stream, group_vars, aggregates)
```

Key helper functions:
- `extract_group_var_names/1` - Extracts variable names from group variable specs
- `partition_by_group_key/2` - Groups bindings by their key values
- `compute_group_result/3` - Computes aggregates for a group

### 2.6.1.2: Implicit Grouping

Added `implicit_group/2` for handling aggregates without GROUP BY:
- All bindings form a single group
- Computes aggregates over entire solution set

```elixir
@spec implicit_group(Enumerable.t(), [{term(), aggregate_spec()}]) :: binding_stream()
def implicit_group(stream, aggregates)
```

### 2.6.1.3: HAVING Clause Support

Added `having/2` for post-aggregation filtering:
- Delegates to `filter/2` since HAVING uses the same expression evaluation
- Filters groups after aggregates are computed

```elixir
@spec having(Enumerable.t(), term()) :: binding_stream()
def having(grouped_stream, having_expr)
```

### Aggregate Computation

Implemented aggregate computation for all SPARQL aggregate functions:
- `COUNT(*)` - Counts all solutions in group
- `COUNT(expr)` - Counts non-null expression values
- `SUM(expr)` - Sums numeric values with type promotion
- `AVG(expr)` - Computes average (always returns decimal)
- `MIN(expr)` - Finds minimum using SPARQL term ordering
- `MAX(expr)` - Finds maximum using SPARQL term ordering
- `GROUP_CONCAT(expr, separator)` - Concatenates string values
- `SAMPLE(expr)` - Returns arbitrary value from group

All aggregates support the `DISTINCT` modifier for duplicate elimination.

### Numeric Type Handling

- Proper type promotion: integer → decimal → double
- Extracts numeric values from RDF typed literals
- Formats results with correct XSD datatypes
- Supports both 4-element and 3-element literal formats for input compatibility

### Query Integration

Added `:group` pattern handling to `execute_pattern/2` in query.ex:
- Routes to `implicit_group/2` when group_vars is empty
- Routes to `group_by/3` when group_vars are specified

## Test Coverage

Added 17 new tests covering:

| Test Category | Count |
|---------------|-------|
| group_by/3 - single variable grouping | 1 |
| group_by/3 - multiple variable grouping | 1 |
| COUNT(*) | 1 |
| COUNT(expr) | 1 |
| SUM aggregate | 1 |
| AVG aggregate | 1 |
| MIN aggregate | 1 |
| MAX aggregate | 1 |
| GROUP_CONCAT | 1 |
| SAMPLE | 1 |
| DISTINCT modifier | 1 |
| Empty group variables | 1 |
| implicit_group/2 - basic | 1 |
| implicit_group/2 - empty input | 1 |
| having/2 - filtering | 1 |
| **Total** | **17** |

## Technical Notes

### Literal Format Compatibility

The codebase uses 4-element typed literal format: `{:literal, :typed, value, type}`

The implementation handles both formats:
- 4-element: `{:literal, :typed, "10", "http://www.w3.org/2001/XMLSchema#integer"}`
- 3-element (legacy): `{:literal, {:typed, "http://www.w3.org/2001/XMLSchema#integer"}, "10"}`

All output uses the standard 4-element format.

### Type Promotion Rules

| Left Type | Right Type | Result |
|-----------|------------|--------|
| integer | integer | integer |
| integer | decimal | decimal |
| integer | double | double |
| decimal | decimal | decimal |
| decimal | double | double |
| double | any | double |

### Performance Considerations

- Grouping uses `Enum.reduce` with a map accumulator for O(n) partitioning
- Aggregate computation is done once per group
- DISTINCT uses `Enum.uniq/1` for deduplication
- MIN/MAX use `Enum.min/max` with custom comparator

## Next Task

Task 2.6.2: Aggregate Functions - Extend expression evaluation with aggregate function support in the algebra compiler.
