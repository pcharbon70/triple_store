# Task 1.2.4: Iterator API - Summary

## Overview
Implemented prefix iterators for RocksDB via Rustler NIFs, enabling efficient range queries over column families. Also includes an Elixir Stream wrapper for ergonomic iteration.

## Completed Sub-tasks

### 1.2.4.1: Implement `prefix_iterator(db, cf, prefix)`
- Creates a forward iterator starting at the given prefix
- Returns iterator resource for subsequent operations
- Handles empty prefix for full column family scans

### 1.2.4.2: Implement `iterator_next(iter)`
- Returns `{:ok, key, value}` for the next matching entry
- Returns `:iterator_end` when exhausted or prefix boundary crossed
- Automatic prefix boundary detection

### 1.2.4.3: Implement `iterator_seek(iter, target)`
- Repositions iterator to key >= target
- Essential for Leapfrog Triejoin in Phase 3
- Creates new internal iterator at seek position

### 1.2.4.4: Implement `iterator_close(iter)`
- Releases iterator resources
- Idempotent - returns error on double-close
- Automatic cleanup when garbage collected

### 1.2.4.5: Create Elixir Stream wrapper
- `prefix_stream/3` wraps iterator in lazy Stream
- Automatic cleanup via `Stream.resource/3`
- Supports all Stream operations (take, filter, map, etc.)

## Technical Details

### Iterator Resource Management
```rust
pub struct IteratorRef {
    iterator: Mutex<Option<DBIteratorWithThreadMode<'static, DB>>>,
    _db_ref: Arc<ResourceArc<DbRef>>,
    prefix: Vec<u8>,
    cf_name: String,
}
```

- `Mutex` for mutable iterator access from multiple calls
- `Arc<ResourceArc<DbRef>>` keeps database alive while iterator exists
- Prefix stored for boundary checking on each `next()`
- Unsafe transmute to `'static` lifetime is safe because DbRef Arc ensures database outlives iterator

### Prefix Boundary Detection
```rust
if !key.starts_with(&iter_ref.prefix) {
    return Ok(atoms::iterator_end().encode(env));
}
```

- Each `iterator_next` checks if key still matches prefix
- Returns `:iterator_end` when prefix boundary crossed
- No need for RocksDB's built-in prefix features

### Stream Wrapper Implementation
```elixir
Stream.resource(
  fn -> iter end,
  &stream_next/1,
  fn iter -> iterator_close(iter) end
)
```

- Resource cleanup via third function
- Lazy evaluation - items fetched on demand
- Halts on `:iterator_end` or error

## Files Changed

### Modified
- `native/rocksdb_nif/src/lib.rs` - Added iterator NIFs
- `lib/triple_store/backend/rocksdb/nif.ex` - Added function declarations and Stream wrapper

### Created
- `test/triple_store/backend/rocksdb/iterator_test.exs` - 34 tests

## New Functions Added

| Function | Description |
|----------|-------------|
| `prefix_iterator/3` | Create prefix iterator |
| `iterator_next/1` | Get next key-value pair |
| `iterator_seek/2` | Seek to specific key |
| `iterator_close/1` | Close iterator |
| `iterator_collect/1` | Collect all remaining entries |
| `prefix_stream/3` | Create Elixir Stream wrapper |

## Error Types Added
- `:iterator_end` - Iterator exhausted or prefix boundary crossed
- `:iterator_closed` - Operation on closed iterator
- `:iterator_failed` - RocksDB iteration error

## Test Coverage
- 34 new tests covering all iterator operations
- Tests for prefix filtering and boundary detection
- Tests for seek operations including non-existent keys
- Tests for concurrent iteration from multiple tasks
- Tests for edge cases (empty prefix, single byte prefix, large results)
- Tests for Stream wrapper behavior

## Test Results
- 120 total project tests passing (34 new + 86 existing)
- Credo: no issues found

## Next Steps
- Task 1.2.5: Implement Snapshot Support for consistent reads during updates
