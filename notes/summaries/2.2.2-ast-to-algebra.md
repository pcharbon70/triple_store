# Task 2.2.2: AST to Algebra Compilation

## Summary

Implemented the AST compilation functions that transform parsed SPARQL queries into a structured compiled query format. Since the spargebra parser already produces algebra-like nodes, this task focused on normalization, validation, and providing convenient analysis functions.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/algebra.ex` - Added ~300 lines of AST compilation code
- `test/triple_store/sparql/algebra_test.exs` - Added 35 new tests (107 total)

### New Type Definition

```elixir
@type compiled_query :: %{
  type: :select | :construct | :ask | :describe,
  pattern: t(),
  dataset: term() | nil,
  base_iri: String.t() | nil,
  template: [triple()] | nil
}
```

### Core Compilation Functions

1. **`from_ast/1`** - Compiles a parsed AST into a compiled query structure
   - Extracts query type (:select, :construct, :ask, :describe)
   - Extracts the algebra pattern
   - Extracts metadata (dataset, base_iri, template)
   - Validates the pattern structure
   - Returns `{:ok, compiled_query}` or `{:error, reason}`

2. **`from_ast!/1`** - Same as above but raises on error

3. **`extract_pattern/1`** - Extracts just the algebra pattern from AST or compiled query

### Analysis Functions

1. **`result_variables/1`** - Returns projected variables for SELECT queries
   - Handles DISTINCT, REDUCED, ORDER BY, SLICE modifiers
   - Handles SELECT * expansion

2. **`collect_bgps/1`** - Collects all BGP nodes from an algebra tree
   - Useful for selectivity analysis and index planning

3. **`triple_count/1`** - Counts total triple patterns in the query

4. **`has_optional?/1`** - Checks for LEFT JOIN (OPTIONAL)

5. **`has_union?/1`** - Checks for UNION

6. **`has_filter?/1`** - Checks for FILTER

7. **`has_aggregation?/1`** - Checks for GROUP BY

8. **`collect_filters/1`** - Collects all FILTER expressions

## Key Insight

The spargebra parser already produces algebra-like structures, so the "compilation" step is primarily:
- Normalizing the query wrapper structure
- Validating the algebra tree
- Providing convenient access functions

The parser handles:
- SELECT * expansion to all in-scope variables
- Combining multiple FILTERs into AND expressions
- Proper nesting of modifiers (DISTINCT, ORDER BY, SLICE)

## Test Coverage

35 new tests covering:
- `from_ast/1` for all query types (SELECT, CONSTRUCT, ASK, DESCRIBE)
- `from_ast!/1` success and error cases
- `extract_pattern/1` for raw AST and compiled queries
- `result_variables/1` with various modifiers
- `collect_bgps/1` for single and multiple BGPs
- `triple_count/1` across various patterns
- `has_optional?/1`, `has_union?/1`, `has_filter?/1`, `has_aggregation?/1`
- `collect_filters/1` for single and combined filters

## Dependencies

No new dependencies. Uses existing Algebra module functions (validate, fold).

## Next Steps

Task 2.2.3: Expression Compilation - Compile SPARQL expressions (FILTER conditions, BIND expressions) to evaluable form including:
- Arithmetic expressions (+, -, *, /)
- Comparison expressions (=, !=, <, >, <=, >=)
- Logical expressions (&&, ||, !)
- Built-in functions (STR, LANG, DATATYPE, BOUND, etc.)
- Aggregate functions (COUNT, SUM, AVG, MIN, MAX, GROUP_CONCAT)
