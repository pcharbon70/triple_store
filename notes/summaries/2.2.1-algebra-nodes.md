# Task 2.2.1: Algebra Node Types

## Summary

Implemented the SPARQL Algebra module defining all algebra node types that represent SPARQL query operations after parsing. The algebra forms the intermediate representation between parsing and query execution, enabling optimization passes and structured traversal.

## Implementation Details

### Files Created

- `lib/triple_store/sparql/algebra.ex` - Main algebra module (900+ lines)
- `test/triple_store/sparql/algebra_test.exs` - Comprehensive test suite (72 tests)

### Algebra Node Types Implemented

1. **Basic Patterns**
   - `:bgp` - Basic Graph Pattern containing triple patterns
   - `:triple` - Individual triple pattern (subject, predicate, object)

2. **Joins**
   - `:join` - Inner join between two patterns
   - `:left_join` - Left outer join for OPTIONAL (with optional filter)
   - `:minus` - Anti-join for MINUS

3. **Set Operations**
   - `:union` - Multiset union of two patterns

4. **Filtering**
   - `:filter` - Filter solutions based on expression

5. **Extension**
   - `:extend` - Bind new variable to expression (BIND)
   - `:group` - GROUP BY with aggregates

6. **Projection**
   - `:project` - Variable projection for SELECT

7. **Duplicate Modifiers**
   - `:distinct` - Remove duplicate solutions
   - `:reduced` - Allow optional duplicate removal

8. **Solution Modifiers**
   - `:order_by` - Sort solutions by expressions
   - `:slice` - OFFSET and LIMIT pagination

9. **Additional Nodes**
   - `:values` - Inline data (VALUES clause)
   - `:graph` - Named graph pattern
   - `:service` - Federated query SERVICE
   - `:path` - Property path patterns

### Type Definitions

```elixir
@type rdf_term ::
  {:variable, String.t()}
  | {:named_node, String.t()}
  | {:blank_node, String.t()}
  | {:literal, :simple, String.t()}
  | {:literal, :lang, String.t(), String.t()}
  | {:literal, :typed, String.t(), String.t()}
```

### Analysis Functions

- `node_type/1` - Get the type atom of a node
- `is_type?/2` - Check if node matches a type
- `variables/1` - Extract all variables from tree
- `children/1` - Get child nodes
- `fold/3` - Bottom-up fold over tree
- `map/2` - Transform tree with function

### Validation

- `validate/1` - Validates algebra tree structure
- Returns `:ok` or `{:error, reason}`
- Validates nested structures recursively

### Pretty Printing

- `to_string/1` - Human-readable representation

## Parser Compatibility

The algebra module is designed to work seamlessly with the parser output from Section 2.1. Tests verify:

- Parser output matches algebra node structure
- Validation passes for all parser-generated trees
- Variable extraction works on parser output
- All query features (OPTIONAL, FILTER, UNION, ORDER BY, LIMIT, DISTINCT, GROUP BY) are handled

## Test Coverage

72 tests covering:
- Node type constructors (all 16 types)
- Node analysis functions
- Tree traversal (fold, map)
- Validation (valid and invalid inputs)
- Pretty printing
- Parser integration

## Dependencies

No new dependencies added. Uses only Elixir standard library.

## Next Steps

Task 2.2.2: AST to Algebra Compilation - Implement the compiler transforming parsed AST to algebra trees with proper normalization.
