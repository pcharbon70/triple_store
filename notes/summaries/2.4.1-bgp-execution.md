# Task 2.4.1: BGP Execution

## Summary

Implemented Basic Graph Pattern (BGP) execution using index nested loop join. The executor takes algebra patterns and returns streams of solution bindings, integrating with the existing Index and Dictionary layers.

## Implementation Details

### Files Created

- `lib/triple_store/sparql/executor.ex` - SPARQL executor module (~400 lines)
- `test/triple_store/sparql/executor_test.exs` - Comprehensive test suite (13 tests)

### Files Modified

- `lib/triple_store/dictionary/manager.ex` - Added `get_db/1` function for read-only database access

### Core Functions

#### `Executor.execute_bgp/3`

Main entry point for BGP execution:

```elixir
@spec execute_bgp(context(), list(), binding()) :: {:ok, binding_stream()} | {:error, term()}
def execute_bgp(ctx, patterns, initial_binding \\ %{})
```

- Returns `Stream.t(binding)` where binding is `%{String.t() => rdf_term}`
- Reorders patterns by selectivity using the optimizer
- Executes patterns sequentially using nested loop join
- Empty pattern returns single empty binding (SPARQL semantics)

#### `Executor.execute_pattern/3`

Executes a single triple pattern against a binding stream:

```elixir
@spec execute_pattern(context(), binding_stream(), tuple()) :: {:ok, binding_stream()}
```

### Algorithm

1. **Pattern Reordering**: Uses `Optimizer.reorder_bgp_patterns/1` to place selective patterns first
2. **Nested Loop Join**: For each binding in the stream, match against the next pattern
3. **Variable Substitution**: Bound variables are substituted into patterns before index lookup
4. **Binding Extension**: Matched variables extend the current binding

### Key Design Decisions

1. **Lazy Evaluation**: Uses Elixir Streams for memory-efficient processing of large result sets
2. **Dictionary Integration**: Encodes/decodes terms via Dictionary module, supporting inline-encoded numerics
3. **Index Selection**: Leverages `Index.select_index/1` for optimal index selection per pattern
4. **Not-Found Handling**: Terms not in dictionary result in empty stream (no matches possible)

### Context Structure

The executor requires a context map with database references:

```elixir
ctx = %{
  db: db_reference,           # RocksDB database
  dict_manager: manager_pid   # Dictionary Manager process
}
```

### Binding Representation

Solution bindings are maps from variable names to algebra terms:

```elixir
%{
  "s" => {:named_node, "http://example.org/Alice"},
  "name" => {:literal, :simple, "Alice"}
}
```

## Test Coverage

13 tests covering:

1. Empty pattern returns single empty binding
2. Single pattern with no matches returns empty stream
3. Single pattern returns matching bindings
4. Multiple matching triples return multiple bindings
5. Pattern with bound subject filters results
6. Two patterns join on shared variable
7. Join with shared variable produces correct bindings
8. Initial binding constrains results
9. Pattern with all variables returns all triples
10. Same variable in multiple positions requires consistent binding
11. `empty_stream/0` returns empty stream
12. `unit_stream/0` returns stream with single empty binding
13. `execute_pattern/3` executes single pattern against bindings

## Usage Examples

```elixir
# Create execution context
{:ok, db} = NIF.open(db_path)
{:ok, manager} = Manager.start_link(db: db)
ctx = %{db: db, dict_manager: manager}

# Execute a BGP
patterns = [
  {:triple, {:variable, "s"}, {:named_node, "http://ex.org/name"}, {:variable, "name"}}
]
{:ok, stream} = Executor.execute_bgp(ctx, patterns)
results = Enum.to_list(stream)
# => [%{"s" => {:named_node, "..."}, "name" => {:literal, :simple, "Alice"}}, ...]

# Execute with initial binding (pre-bound variables)
initial = %{"s" => {:named_node, "http://ex.org/Alice"}}
{:ok, stream} = Executor.execute_bgp(ctx, patterns, initial)
```

## Performance Characteristics

- **Pattern Reordering**: O(nÂ²) greedy algorithm for n patterns
- **Index Lookup**: O(log n) per pattern using RocksDB prefix iteration
- **Stream Processing**: Lazy evaluation - memory usage proportional to current result set
- **Join**: Nested loop join - O(n * m) for n left bindings and m right matches

## Completed Tasks

- [x] 2.4.1.1 Implement `execute_bgp(db, patterns)` returning `Stream.t(bindings)`
- [x] 2.4.1.2 Order patterns by selectivity before execution
- [x] 2.4.1.3 Implement variable substitution for bound variables
- [x] 2.4.1.4 Implement binding extension for matched variables
- [x] 2.4.1.5 Handle empty pattern (returns single empty binding)

## Next Steps

Task 2.4.2: Join Execution - Implement join operations between result streams:
- Nested loop join for small inputs
- Hash join for larger inputs
- Left outer join for OPTIONAL semantics
