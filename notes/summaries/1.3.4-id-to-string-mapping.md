# Task 1.3.4: ID-to-String Mapping Implementation - Summary

## Overview

Implemented the reverse mapping from 64-bit IDs to RDF term strings using the `id2str` column family in RocksDB. This complements Task 1.3.3 (String-to-ID Mapping) to provide bidirectional term resolution.

## Implementation

### Core Module

**`lib/triple_store/dictionary/id_to_string.ex`**

Provides reverse lookup from term IDs to RDF structs:
- `lookup_term/2` - Look up single term by ID (dictionary or inline)
- `lookup_terms/2` - Batch lookup for multiple IDs
- `decode_term/1` - Parse binary encoding back to RDF term struct

### Term Decoding Format

Binaries are decoded based on type prefix (matching StringToId encoding):

| Type Prefix | Format | Decodes To |
|-------------|--------|------------|
| `1` | `<<1, uri_string::binary>>` | `RDF.IRI` |
| `2` | `<<2, bnode_id::binary>>` | `RDF.BlankNode` |
| `3, 0` | `<<3, 0, value::binary>>` | Plain `RDF.Literal` |
| `3, 1` | `<<3, 1, datatype, 0, value>>` | Typed `RDF.Literal` |
| `3, 2` | `<<3, 2, lang, 0, value>>` | Language-tagged `RDF.Literal` |

### Key Features

1. **Dictionary-Allocated Terms**
   - Lookup in `id2str` column family using 64-bit big-endian key
   - Returns decoded RDF term struct or `:not_found`

2. **Inline-Encoded IDs**
   - Integer, decimal, and datetime values encoded directly in ID bits
   - No database lookup required - computed from ID
   - Returns appropriate `RDF.Literal` struct

3. **Batch Operations**
   - `lookup_terms/2` efficiently handles multiple IDs
   - Mixes dictionary and inline IDs in single batch
   - Returns list of `{:ok, term}` or `:not_found` per ID

### Public API

| Function | Description |
|----------|-------------|
| `lookup_term(db, id)` | Look up single term, returns `{:ok, term}`, `:not_found`, or `{:error, reason}` |
| `lookup_terms(db, ids)` | Batch lookup, returns `{:ok, [result, ...]}` |
| `decode_term(binary)` | Parse binary to RDF term, returns `{:ok, term}` or `{:error, :invalid_encoding}` |

## Test Coverage

**`test/triple_store/dictionary/id_to_string_test.exs`** - 40 tests

| Test Category | Tests |
|---------------|-------|
| decode_term for URIs | 3 |
| decode_term for BNodes | 2 |
| decode_term for Literals | 5 |
| decode_term edge cases | 2 |
| lookup_term dictionary-allocated | 5 |
| lookup_term inline-encoded | 7 |
| lookup_terms batch operations | 5 |
| Roundtrip encoding/decoding | 8 |
| Edge cases | 3 |

Key test scenarios:
- URI decoding with special characters and Unicode
- Literal decoding with datatypes and language tags
- Integer, decimal, datetime inline decoding
- Large batch operations (100 terms)
- Very long URIs (10,000 characters)
- Null bytes in literal values

## Files Changed

### Created
- `lib/triple_store/dictionary/id_to_string.ex` (~250 lines)
- `test/triple_store/dictionary/id_to_string_test.exs` (~400 lines)
- `notes/summaries/1.3.4-id-to-string-mapping.md` (this file)

## Test Results

- **Total tests**: 391 (40 new + 351 existing)
- **All tests passing**
- **Credo**: No issues in new code (1 existing software design suggestion)

## Usage Example

```elixir
# Start manager and create some terms
{:ok, manager} = Manager.start_link(db: db_ref)
{:ok, uri_id} = Manager.get_or_create_id(manager, RDF.iri("http://example.org"))
{:ok, bnode_id} = Manager.get_or_create_id(manager, RDF.bnode("b1"))

# Reverse lookup - dictionary-allocated terms
{:ok, uri} = IdToString.lookup_term(db, uri_id)
# uri == %RDF.IRI{value: "http://example.org"}

{:ok, bnode} = IdToString.lookup_term(db, bnode_id)
# bnode == %RDF.BlankNode{value: "b1"}

# Reverse lookup - inline-encoded terms (no DB needed)
{:ok, int_id} = Dictionary.encode_integer(42)
{:ok, lit} = IdToString.lookup_term(db, int_id)
# lit == RDF.literal(42)

# Batch lookup
{:ok, results} = IdToString.lookup_terms(db, [uri_id, int_id, unknown_id])
# results == [{:ok, uri}, {:ok, int_lit}, :not_found]

# Direct binary decoding
{:ok, term} = IdToString.decode_term(<<1, "http://example.org">>)
# term == %RDF.IRI{value: "http://example.org"}
```

## Design Notes

### Symmetry with StringToId

The encoding format in IdToString exactly mirrors StringToId:
- Same type prefixes (1=URI, 2=BNode, 3=Literal)
- Same literal subtypes (0=plain, 1=typed, 2=language)
- Same null byte separator for typed/language literals

### Inline vs Dictionary Decision

The `lookup_term/2` function checks `Dictionary.inline_encoded?(id)` to determine the lookup path:
- Inline IDs: Extract value directly from ID bits via Dictionary module
- Dictionary IDs: Lookup in id2str column family

### Performance Considerations

- Read-only operations go directly to RocksDB NIF (no GenServer)
- Inline IDs avoid database access entirely
- Batch operations iterate without early termination on :not_found

## Next Steps

- Task 1.3.5: Inline Numeric Encoding (verification - mostly complete)
- Task 1.3.6: Unit Tests (consolidation of dictionary tests)
