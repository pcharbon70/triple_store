# Task 1.3.2: Sequence Counter Implementation - Summary

## Overview

Implemented the atomic sequence counter GenServer for generating unique term IDs. Uses `:atomics` for lock-free increments with periodic persistence to RocksDB, ensuring high throughput ID generation while maintaining durability.

## Implementation

### Core Module

**`lib/triple_store/dictionary/sequence_counter.ex`**

A GenServer that manages separate sequence counters for each dictionary-allocated type:
- URI (type tag 1)
- BNode (type tag 2)
- Literal (type tag 3)

### Key Features

1. **Lock-Free Atomic Increments**
   - Uses `:atomics.add_get/3` for O(1) atomic increment-and-return
   - Separate counter per type (indices 1-3 in atomics array)

2. **Periodic Persistence**
   - Flushes to RocksDB every 1000 allocations per type (`Dictionary.flush_interval()`)
   - Uses `__seq_counter__<type>` keys in str2id column family
   - 64-bit big-endian encoding for counter values

3. **Recovery with Safety Margin**
   - On startup, loads persisted value and adds 1000 (`Dictionary.safety_margin()`)
   - Prevents ID reuse even if crash occurred before last flush
   - Fresh database starts at safety_margin (1000)

4. **Graceful Shutdown**
   - Flushes all counters via `terminate/2` callback
   - Also supports explicit `flush/1` and `stop/1` calls

### Public API

| Function | Description |
|----------|-------------|
| `start_link/1` | Start counter with `:db` reference and optional `:name` |
| `next_id/2` | Get next ID for type (returns fully-encoded term ID) |
| `current/2` | Get current sequence without incrementing |
| `flush/1` | Force persistence of all counters |
| `stop/1` | Graceful shutdown with flush |

### Error Handling

- `{:error, :sequence_overflow}` - Sequence exhausted (>576 quadrillion IDs)
- `{:error, :invalid_type}` - Unknown type requested
- Persistence failures are logged and retried on next flush interval

## Test Coverage

**`test/triple_store/dictionary/sequence_counter_test.exs`** - 20 tests

| Test Category | Tests |
|---------------|-------|
| start_link/1 | 3 |
| next_id/2 | 6 |
| current/2 | 2 |
| flush/1 | 1 |
| recovery with safety margin | 2 |
| periodic persistence | 1 |
| concurrent access | 2 |
| stop/1 | 1 |
| edge cases | 2 |

Key test scenarios:
- Counter initialization with safety margin on fresh DB
- Valid ID generation for all types
- Monotonically increasing IDs
- Independent sequences per type
- Safety margin prevents ID reuse after crash
- Auto-flush after flush_interval allocations
- Concurrent ID generation (100 tasks Ã— 10 IDs each)
- Large batch generation (5000 IDs)

## Files Changed

### Created
- `lib/triple_store/dictionary/sequence_counter.ex` (~400 lines)
- `test/triple_store/dictionary/sequence_counter_test.exs` (~390 lines)
- `notes/summaries/1.3.2-sequence-counter.md` (this file)

## Test Results

- **Total tests**: 309 (20 new + 289 existing)
- **All tests passing**
- **Credo**: No issues found

## Usage Example

```elixir
# Start counter with database reference
{:ok, counter} = SequenceCounter.start_link(db: db_ref)

# Get next ID for URI type
{:ok, id} = SequenceCounter.next_id(counter, :uri)
# id is a fully-encoded 64-bit term ID

# Decode to verify
{:uri, seq} = Dictionary.decode_id(id)
# seq is the raw sequence number (e.g., 1001)

# Force flush to disk
:ok = SequenceCounter.flush(counter)

# Graceful shutdown
:ok = SequenceCounter.stop(counter)
```

## Design Notes

### Why GenServer + Atomics?

The GenServer provides:
- Lifecycle management (supervision tree integration)
- Periodic persistence coordination
- Clean shutdown handling

The `:atomics` module provides:
- Lock-free atomic increments (no GenServer bottleneck for hot path)
- Memory-efficient (single 64-bit word per counter)
- BEAM-native performance

### Safety Margin Rationale

With flush_interval=1000 and safety_margin=1000:
- Worst case: crash immediately before flush
- Up to 999 unflushed IDs in memory
- On restart: load persisted + 1000 = guaranteed no overlap

This trades ~0.1% ID space for crash safety.

## Next Steps

- Task 1.3.3: String-to-ID Mapping (str2id column family)
- Task 1.3.4: ID-to-String Mapping (id2str column family)
