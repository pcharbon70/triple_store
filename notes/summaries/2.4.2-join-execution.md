# Task 2.4.2: Join Execution

## Summary

Implemented join operations between binding streams for SPARQL query execution. The executor now supports nested loop join, hash join, and left outer join (for OPTIONAL semantics), with automatic strategy selection based on input characteristics.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/executor.ex` - Added join execution functions (~300 lines added)
- `test/triple_store/sparql/executor_test.exs` - Added 30 new tests (43 total)

### Core Functions

#### `Executor.join/3`

Main entry point for inner join with strategy selection:

```elixir
@spec join(Enumerable.t(), Enumerable.t(), keyword()) :: binding_stream()
def join(left, right, opts \\ [])
```

Options:
- `:strategy` - Force `:nested_loop`, `:hash`, or `:auto` (default)

#### `Executor.nested_loop_join/2`

O(n*m) nested loop join for small inputs:

```elixir
@spec nested_loop_join(Enumerable.t(), Enumerable.t()) :: binding_stream()
def nested_loop_join(left, right)
```

- Materializes right side once
- Iterates all right bindings for each left binding
- Best for small inputs or when early termination is likely

#### `Executor.hash_join/2`

O(n+m) hash join for larger inputs:

```elixir
@spec hash_join(Enumerable.t(), Enumerable.t()) :: binding_stream()
def hash_join(left, right)
```

- Builds hash table on shared variables from left side
- Probes with right side bindings
- Falls back to cartesian product if no shared variables
- Best for larger inputs where build side fits in memory

#### `Executor.left_join/3`

Left outer join for OPTIONAL semantics:

```elixir
@spec left_join(Enumerable.t(), Enumerable.t(), keyword()) :: binding_stream()
def left_join(left, right, opts \\ [])
```

Options:
- `:filter` - Filter function for OPTIONAL { ... FILTER ... } patterns

Preserves all left bindings, extending with right when compatible.

#### `Executor.merge_bindings/2`

Binding compatibility check and merge:

```elixir
@spec merge_bindings(binding(), binding()) :: {:ok, binding()} | :incompatible
def merge_bindings(binding1, binding2)
```

- Returns `{:ok, merged}` when all shared variables have equal values
- Returns `:incompatible` when any shared variable has different values

### Algorithm Details

#### Hash Join Algorithm

1. Materialize both sides
2. Find shared variables between left and right
3. If no shared variables: compute cartesian product
4. Build hash table: group left bindings by join key values
5. Probe: for each right binding, lookup matching left bindings by key
6. Merge compatible bindings

#### Left Outer Join Algorithm

1. Materialize right side
2. For each left binding:
   - Find all compatible right bindings
   - Apply optional filter function
   - If matches exist: emit extended bindings
   - If no matches: emit original left binding (OPTIONAL semantics)

### Key Design Decisions

1. **Lazy Evaluation**: All joins return Elixir Streams for memory efficiency
2. **Automatic Strategy**: Default to hash join which handles both small and large inputs well
3. **Binding Compatibility**: Strict equality check on shared variables
4. **OPTIONAL Support**: Left join preserves unmatched rows per SPARQL semantics
5. **Filter Support**: Left join accepts filter function for OPTIONAL { ... FILTER ... }

## Test Coverage

30 new tests covering:

### merge_bindings/2
1. Merges non-overlapping bindings
2. Merges overlapping bindings with same values
3. Returns incompatible for conflicting values
4. Handles empty bindings
5. Handles RDF term values

### bindings_compatible?/2
6. Returns true for compatible bindings
7. Returns false for incompatible bindings

### nested_loop_join/2
8. Joins bindings with shared variables
9. Produces cartesian product for non-overlapping variables
10. Returns empty for empty inputs
11. Handles multiple matches per left binding
12. Filters incompatible bindings

### hash_join/2
13. Joins bindings with shared variables
14. Produces cartesian product for non-overlapping variables
15. Returns empty for empty inputs
16. Handles multiple values for same key
17. Handles multiple join variables

### join/3
18. Default strategy produces correct results
19. nested_loop strategy option works
20. hash strategy option works
21. Hash and nested_loop produce same results

### left_join/3
22. Preserves left bindings when no match on right
23. Extends left bindings when match exists
24. Handles multiple matches per left binding
25. Handles empty right side (all left preserved)
26. Handles empty left side
27. Applies filter function to matches
28. Preserves left when filter rejects all matches
29. Implements OPTIONAL semantics correctly

### Integration
30. Join produces same results as BGP multi-pattern

## Usage Examples

```elixir
# Inner join two binding streams
left = [%{"x" => 1, "y" => "a"}]
right = [%{"x" => 1, "z" => "b"}]
results = Executor.join(left, right) |> Enum.to_list()
# => [%{"x" => 1, "y" => "a", "z" => "b"}]

# Force nested loop strategy
results = Executor.join(left, right, strategy: :nested_loop)

# Left outer join for OPTIONAL
# ?person :name ?name . OPTIONAL { ?person :age ?age }
names = [%{"person" => p1, "name" => "Alice"}, %{"person" => p2, "name" => "Bob"}]
ages = [%{"person" => p1, "age" => 30}]  # Only Alice has age
results = Executor.left_join(names, ages) |> Enum.to_list()
# Alice has age, Bob doesn't but is still in results

# Left join with filter (OPTIONAL { ... FILTER ... })
filter_fn = fn binding -> binding["age"] > 18 end
results = Executor.left_join(names, ages, filter: filter_fn)
```

## Performance Characteristics

- **Nested Loop Join**: O(n*m) time, O(m) space (right side materialized)
- **Hash Join**: O(n+m) time, O(n+m) space (both sides materialized)
- **Left Join**: O(n*m) time, O(m) space (right side materialized)

For large inputs, hash join is significantly faster. For very small inputs or when streaming is important, nested loop may be preferred.

## Completed Tasks

- [x] 2.4.2.1 Implement nested loop join for small inputs
- [x] 2.4.2.2 Implement hash join for larger inputs
- [x] 2.4.2.3 Implement left outer join for OPTIONAL semantics
- [x] 2.4.2.4 Handle compatible binding merge

## Next Steps

Task 2.4.3: Union Execution - Execute UNION as concatenation of result streams:
- Implement `execute_union(db, left, right)` concatenating streams
- Handle variable alignment across branches
- Preserve ordering within branches
