# Task 2.3.3: BGP Reordering Optimization

## Summary

Implemented BGP (Basic Graph Pattern) reordering optimization that places the most selective triple patterns first. This reduces intermediate result sizes during query execution by processing patterns that match fewer triples before those that match many.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/optimizer.ex` - Extended with BGP reordering (~280 new lines)
- `test/triple_store/sparql/optimizer_test.exs` - Added 24 new tests (91 total)

### Core Functions

#### `Optimizer.reorder_bgp_patterns/2`
Reorders triple patterns within BGPs based on selectivity estimates.

```elixir
@spec reorder_bgp_patterns(algebra(), map()) :: algebra()
def reorder_bgp_patterns(algebra, stats \\ %{})
```

#### `Optimizer.estimate_selectivity/3`
Estimates the selectivity of a triple pattern. Lower scores indicate more selective patterns.

```elixir
@spec estimate_selectivity(tuple(), MapSet.t(), map()) :: float()
def estimate_selectivity(pattern, bound_vars \\ MapSet.new(), stats \\ %{})
```

### Algorithm

Uses a **greedy algorithm** that repeatedly selects the most selective remaining pattern considering:

1. **Bound positions**: Bound subjects/predicates/objects are more selective than variables
2. **Predicate cardinalities**: Uses statistics to score predicates by frequency
3. **Variable binding propagation**: Variables bound by previous patterns make subsequent patterns more selective

### Selectivity Scoring

Position-based scoring (lower = more selective):

| Position | Bound Value | Unbound Variable | Already-Bound Variable |
|----------|-------------|------------------|----------------------|
| Subject  | 1.0         | 100.0            | 1.0                  |
| Predicate| 0.5-100.0*  | 50.0             | 1.0                  |
| Object   | 2.0-5.0     | 100.0            | 1.0                  |

*Predicate score varies based on cardinality from statistics

### Predicate Cardinality Scoring

When statistics are available:
- Very rare (< 10 triples): 0.5
- Uncommon (< 100 triples): 2.0
- Moderate (< 1000 triples): 10.0
- Common (< 10000 triples): 50.0
- Very common (≥ 10000 triples): 100.0

### Example Transformation

```
# Before:
BGP([
  ?x ?p ?o,                              # All variables - very unselective
  <Bob> <knows> ?y,                      # Bound S and P - very selective
  ?a ?b ?c                               # All variables - unselective
])

# After:
BGP([
  <Bob> <knows> ?y,                      # Most selective first
  ?x ?p ?o,                              # Less selective
  ?a ?b ?c                               # Least selective
])
```

### Variable Binding Propagation

The algorithm considers that once a pattern binds a variable, subsequent patterns using that variable become more selective:

```
# Input: [?a ?b ?c, ?x ?p ?o, <Bob> <knows> ?x]
#
# Step 1: Select <Bob> <knows> ?x (most selective, binds ?x)
# Step 2: Select ?x ?p ?o (now ?x is bound, so more selective than ?a ?b ?c)
# Step 3: Select ?a ?b ?c
#
# Output: [<Bob> <knows> ?x, ?x ?p ?o, ?a ?b ?c]
```

## Optimizer Pipeline

The optimization runs in this order:
1. Constant folding (simplify expressions)
2. BGP reordering (optimize pattern order)
3. Filter push-down (push filters to data sources)

## Test Coverage

24 new tests covering:
- Empty and single-pattern BGPs
- Bound subject/predicate/object preference
- Fully bound pattern ordering
- Variable binding propagation
- Literal object handling
- Reordering through join/union/filter/project/distinct
- Predicate statistics usage
- Left-join handling
- Selectivity estimation
- Integration with optimizer pipeline
- Integration with SPARQL parser

## Usage

```elixir
# With default options (reordering enabled)
optimized = Optimizer.optimize(algebra)

# With predicate statistics
stats = %{
  {:predicate_count, "http://ex.org/rare"} => 5,
  {:predicate_count, "http://ex.org/common"} => 50000
}
optimized = Optimizer.optimize(algebra, stats: stats)

# Disable reordering
optimized = Optimizer.optimize(algebra, reorder_bgp: false)
```

## Notes

- Reordering is applied independently to each BGP in the algebra tree
- Statistics are optional; the optimizer uses heuristics when unavailable
- The greedy algorithm is O(n²) for n patterns, acceptable for typical BGP sizes
- Does not reorder across OPTIONAL or UNION boundaries (preserves semantics)

## Next Steps

Task 2.3.4: Optimizer Pipeline - Combine optimizations and add logging:
- Implement `Optimizer.optimize(algebra, stats)` entry point (done)
- Apply optimizations in optimal order (done)
- Add optimization logging for debugging
- Handle optimization bypass for EXPLAIN queries
