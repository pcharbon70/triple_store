# Task 2.3.1: Filter Push-Down Optimization

## Summary

Implemented the filter push-down optimization pass that moves FILTER expressions as close to their data sources as possible. This reduces intermediate result sizes by filtering earlier in query execution.

## Implementation Details

### Files Created

- `lib/triple_store/sparql/optimizer.ex` - Query optimizer module (~475 lines)
- `test/triple_store/sparql/optimizer_test.exs` - Comprehensive test suite (25 tests)

### Core Functions

#### `Optimizer.optimize/2`
Main entry point for query optimization. Currently applies filter push-down, with hooks for future optimizations.

```elixir
@spec optimize(algebra, keyword()) :: algebra
def optimize(algebra, opts \\ [])

# Options:
# - :push_filters - Enable/disable filter push-down (default: true)
```

#### `Optimizer.push_filters_down/1`
Pushes filter expressions closer to their data sources.

```elixir
@spec push_filters_down(algebra) :: algebra
```

#### `Optimizer.analyze_filters/1`
Returns statistics about filters in an algebra tree for debugging.

### Push-Down Rules Implemented

1. **Push past JOIN**: If a filter only references variables from one side of a join, push it to that side

2. **Push past OPTIONAL left side only**: Filters can be pushed into the LEFT side of a left_join if they only use left-side variables. Never push into the right side (would change OPTIONAL semantics)

3. **Conjunctive filter splitting**: AND expressions are split and each conjunct is pushed independently where possible

4. **Push through modifiers**: Filters are pushed through PROJECT, DISTINCT, REDUCED, ORDER_BY, SLICE, and GRAPH nodes

5. **Stop at boundaries**: Filters are NOT pushed past:
   - UNION (would change semantics)
   - MINUS (conservative)
   - GROUP BY (aggregation boundary)
   - EXTEND when filter uses the extended variable

### Example Transformation

```
# Before optimization:
Filter(?x > 5,
  Join(
    BGP([?x ?p ?o]),
    BGP([?y ?q ?z])
  )
)

# After optimization:
Join(
  Filter(?x > 5,
    BGP([?x ?p ?o])
  ),
  BGP([?y ?q ?z])
)
```

### Conjunctive Filter Splitting Example

```
# Before:
Filter(?x > 5 AND ?y < 10,
  Join(BGP(?x), BGP(?y))
)

# After:
Join(
  Filter(?x > 5, BGP(?x)),
  Filter(?y < 10, BGP(?y))
)
```

## Test Coverage

25 tests covering:
- Filter on single BGP (stays in place)
- Push into left/right side of JOIN
- Filter using both sides stays at join level
- Push into left side of OPTIONAL
- NO push into right side of OPTIONAL
- NO push into UNION
- Conjunctive filter splitting
- Partial splitting with remaining filter
- Push through nested joins
- Push through PROJECT, DISTINCT, ORDER_BY, SLICE
- NO push past GROUP BY
- Push into GRAPH pattern
- EXTEND variable handling
- Parser integration tests
- OPTIONAL semantics preservation

## Dependencies

Uses existing modules:
- `TripleStore.SPARQL.Algebra` - Tree structure and variable extraction
- `TripleStore.SPARQL.Expression` - Expression variable extraction

## Notes

- The optimization is idempotent - running it multiple times produces the same result
- Filter merging: When a filter cannot be pushed past another filter, they are combined with AND
- Variable scoping is respected - filters are only pushed where their variables are in scope

## Next Steps

Task 2.3.2: Constant Folding - Evaluate constant expressions at compile time:
- Evaluate arithmetic on constant operands
- Evaluate comparisons on constant operands
- Simplify always-true/always-false filters
