# Task 2.3.4: Optimizer Pipeline

## Summary

Enhanced the SPARQL query optimizer with a structured pipeline architecture, debug logging, and EXPLAIN mode for query analysis without execution.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/optimizer.ex` - Extended with pipeline structure, logging, and explain mode (~200 new lines)
- `test/triple_store/sparql/optimizer_test.exs` - Added 15 new tests (106 total)

### Core Functions

#### `Optimizer.optimize/2`
Main entry point with enhanced options:

```elixir
@spec optimize(algebra(), [opt()]) :: algebra() | {:explain, map()}
def optimize(algebra, opts \\ [])

# Options:
# - :push_filters - Enable filter push-down (default: true)
# - :fold_constants - Enable constant folding (default: true)
# - :reorder_bgp - Enable BGP pattern reordering (default: true)
# - :stats - Statistics map for selectivity estimation
# - :log - Enable debug logging (default: false)
# - :explain - Return analysis instead of optimizing (default: false)
```

#### `Optimizer.explain/2`
Analyzes query without modifying it:

```elixir
@spec explain(algebra(), keyword()) :: {:explain, map()}
def explain(algebra, opts \\ [])

# Returns:
# - :original - The unmodified algebra tree
# - :optimizations - List of applicable optimizations
# - :statistics - Analysis data (filters, BGP patterns, etc.)
# - :estimated_improvement - :low, :moderate, or :high
```

### Pipeline Architecture

The optimizer runs passes in a specific order:

1. **Constant Folding** - Evaluate constant expressions first
2. **BGP Reordering** - Reorder patterns before pushing filters
3. **Filter Push-Down** - Push filters after patterns are ordered

Each pass is isolated and can be independently enabled/disabled.

### Debug Logging

When `log: true` is passed:

```elixir
# Example output:
[debug] [Optimizer] Starting optimization pipeline (nodes: 5, root_type: filter)
[debug] [Optimizer] Pass constant_folding made changes
[debug] [Optimizer] Pass bgp_reordering - no changes
[debug] [Optimizer] Pass filter_push_down made changes
[debug] [Optimizer] Optimization complete (nodes: 5, root_type: join)
```

### EXPLAIN Mode

Returns detailed analysis without modifying the query:

```elixir
{:explain, %{
  original: algebra,
  optimizations: [:constant_folding, :bgp_reordering, :filter_push_down],
  statistics: %{
    filters: %{
      total_filters: 2,
      pushable_filters: 1,
      blocked_by_optional: 1,
      blocked_by_union: 0
    },
    bgp_patterns: %{
      total_bgps: 2,
      total_patterns: 5,
      multi_pattern_bgps: 1,
      max_patterns_in_bgp: 3
    },
    predicate_stats_available: true
  },
  estimated_improvement: :high
}}
```

### Improvement Estimation

The optimizer estimates potential improvement:
- **:high** - Both filters to push and BGPs to reorder
- **:moderate** - Either filters or BGPs can be optimized
- **:low** - Simple query with nothing significant to optimize

## Test Coverage

15 new tests covering:
- Pipeline with all optimizations enabled
- Disabling individual optimizations
- Logging option behavior
- Stats option passthrough
- Explain mode analysis
- Filter detection in explain
- BGP reordering detection in explain
- Constant folding detection in explain
- Simple query analysis
- BGP statistics collection
- Predicate stats availability
- Respecting disabled optimizations in explain
- Improvement estimation (high/low)
- Direct explain/2 function call

## Usage Examples

```elixir
# Basic optimization
optimized = Optimizer.optimize(algebra)

# With statistics for better BGP ordering
stats = %{
  {:predicate_count, "http://ex.org/type"} => 50000,
  {:predicate_count, "http://ex.org/name"} => 1000
}
optimized = Optimizer.optimize(algebra, stats: stats)

# Enable debug logging
optimized = Optimizer.optimize(algebra, log: true)

# Get analysis without optimizing
{:explain, info} = Optimizer.optimize(algebra, explain: true)
IO.inspect(info.optimizations)  # [:constant_folding, :bgp_reordering, :filter_push_down]
IO.inspect(info.estimated_improvement)  # :high

# Disable specific optimizations
optimized = Optimizer.optimize(algebra,
  fold_constants: false,
  reorder_bgp: true,
  push_filters: true
)
```

## Notes

- Logging uses Elixir's Logger at :debug level
- Explain mode is useful for debugging and understanding query plans
- The pipeline order is carefully chosen for optimal results
- All passes are idempotent and can be run independently

## Completed Tasks

- [x] 2.3.4.1 Implement `Optimizer.optimize(algebra, stats)` entry point
- [x] 2.3.4.2 Apply optimizations in optimal order
- [x] 2.3.4.3 Add optimization logging for debugging
- [x] 2.3.4.4 Handle optimization bypass for EXPLAIN queries

## Next Steps

Task 2.3.5: Unit Tests - Complete the optimizer testing:
- The tests for all optimizer features are now complete (106 tests)
- This effectively completes 2.3.5 as well

Section 2.4: Iterator Execution is the next major section.
