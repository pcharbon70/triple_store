# Task 2.5.2: Streaming Results

## Summary

Implemented streaming query support that returns lazy Elixir Streams instead of fully materialized result lists. The `stream_query/2` and `stream_query/3` functions provide memory-efficient query execution with backpressure-aware consumption and clean early termination.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/query.ex` - Added streaming functions (~80 lines)
- `test/triple_store/sparql/query_test.exs` - Added 18 streaming tests

### Core Functions

#### `Query.stream_query/2`

Main entry point for streaming SPARQL SELECT queries:

```elixir
@spec stream_query(context(), String.t()) :: {:ok, stream_result()} | {:error, term()}
def stream_query(ctx, sparql)
```

- Parses SPARQL string using Parser NIF
- Validates query is SELECT (only SELECT supports streaming)
- Optimizes algebra using Optimizer
- Returns lazy Stream of binding maps

#### `Query.stream_query/3`

Streaming query with options:

```elixir
@spec stream_query(context(), String.t(), keyword()) ::
        {:ok, stream_result()} | {:error, term()}
def stream_query(ctx, sparql, opts)
```

Options:
- `:optimize` - Enable/disable optimization (default: true)
- `:stats` - Statistics for optimizer (predicate cardinalities)
- `:variables` - Project to specific variables (overrides SELECT clause)

#### `Query.stream_query!/3`

Raising variant that throws on error:

```elixir
@spec stream_query!(context(), String.t(), keyword()) :: stream_result()
def stream_query!(ctx, sparql, opts \\ [])
```

### Streaming Pipeline

The streaming pipeline differs from `query/2` in that it:

1. **Validates SELECT only**: Only SELECT queries support streaming (ASK, CONSTRUCT, DESCRIBE require full materialization)
2. **Skips timeout wrapper**: Streams are consumed at caller's pace
3. **Returns lazy Stream**: Pattern execution returns Stream, not materialized list
4. **Deferred modifiers**: DISTINCT, ORDER BY, LIMIT, OFFSET applied as stream transformations

### Backpressure Handling

Streams naturally provide backpressure through Elixir's lazy evaluation:

```elixir
# Consumer controls the pace
{:ok, stream} = Query.stream_query(ctx, sparql)

# Only processes 10 results
stream |> Enum.take(10)

# Stops at first match
stream |> Enum.find(&match?(%{"name" => _}, &1))
```

### Early Termination

Streams support clean early termination:

- `Enum.take/2` - Stops after N results
- `Enum.find/2` - Stops at first match
- `Stream.take_while/2` - Stops on condition
- Manual halt via `Enumerable` protocol

No resources are leaked when streams are partially consumed because the underlying pattern execution uses Elixir Streams throughout.

### Solution Modifier Support

All solution modifiers work with streaming:

| Modifier | Streaming Behavior |
|----------|-------------------|
| DISTINCT | Maintains set of seen bindings, filters duplicates |
| LIMIT | Uses `Stream.take/2` for lazy limit |
| OFFSET | Uses `Stream.drop/2` for lazy offset |
| ORDER BY | Requires full materialization (sorting needs all data) |

Note: ORDER BY forces materialization of the stream portion being sorted, but the overall pipeline remains lazy.

## Test Coverage

18 tests covering:

### Basic Streaming
1. Returns lazy stream of bindings
2. Stream is lazy - doesn't execute until consumed
3. Returns empty stream for no matches
4. Returns error for non-SELECT query
5. Returns error for invalid query

### Options
6. optimize: false skips optimization
7. variables option projects to specified variables

### stream_query!/3
8. Returns stream for valid query
9. Raises for invalid query
10. Raises for non-SELECT query

### Early Termination
11. Enum.take/2 only consumes needed elements
12. Enum.find/2 stops at first match
13. Stream can be consumed multiple times by re-creating

### Solution Modifiers
14. DISTINCT works with streaming
15. LIMIT works with streaming
16. OFFSET works with streaming

### Backpressure
17. Stream respects consumer pace via lazy evaluation
18. Chaining stream operations maintains laziness

## Usage Examples

```elixir
# Basic streaming
{:ok, stream} = Query.stream_query(ctx, "SELECT ?s ?p ?o WHERE { ?s ?p ?o }")
results = Enum.to_list(stream)

# Take only first 100 results (memory efficient)
{:ok, stream} = Query.stream_query(ctx, "SELECT ?s WHERE { ?s a ?type }")
first_100 = stream |> Enum.take(100)

# Find first match
{:ok, stream} = Query.stream_query(ctx, "SELECT ?name WHERE { ?s foaf:name ?name }")
alice = stream |> Enum.find(fn b -> b["name"] == {:literal, :simple, "Alice"} end)

# Process in chunks
{:ok, stream} = Query.stream_query(ctx, "SELECT ?s WHERE { ?s ?p ?o }")
stream
|> Stream.chunk_every(1000)
|> Enum.each(&process_batch/1)

# With options
{:ok, stream} = Query.stream_query(ctx, sparql,
  optimize: false,
  variables: ["name", "email"]
)

# Raising variant
stream = Query.stream_query!(ctx, "SELECT ?s WHERE { ?s ?p ?o }")
```

## Comparison: query/2 vs stream_query/2

| Aspect | query/2 | stream_query/2 |
|--------|---------|----------------|
| Return type | `{:ok, [binding]}` | `{:ok, Stream.t()}` |
| Memory usage | O(n) for n results | O(1) constant |
| Timeout support | Yes | No (caller controls) |
| Query types | All (SELECT, ASK, CONSTRUCT, DESCRIBE) | SELECT only |
| Early termination | N/A | Full support |
| Backpressure | N/A | Full support |

## Completed Tasks

- [x] 2.5.2.1 Implement `stream_query/2` returning Stream
- [x] 2.5.2.2 Support backpressure-aware consumption
- [x] 2.5.2.3 Handle early termination cleanly

## Next Steps

Task 2.5.3: Prepared Queries
- Implement `TripleStore.prepare(ctx, sparql)` for query compilation
- Cache compiled queries for repeated execution
- Support parameterized queries with bound variables
