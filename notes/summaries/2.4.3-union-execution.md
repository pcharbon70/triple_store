# Task 2.4.3: Union Execution

## Summary

Implemented UNION execution for SPARQL query processing. The executor now supports concatenating binding streams from multiple graph patterns, with optional variable alignment for consistent result schemas.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/executor.ex` - Added union execution functions (~180 lines added)
- `test/triple_store/sparql/executor_test.exs` - Added 27 new tests (70 total)

### Core Functions

#### `Executor.union/2`

Basic UNION concatenation:

```elixir
@spec union(Enumerable.t(), Enumerable.t()) :: binding_stream()
def union(left, right)
```

- Concatenates results from left branch followed by right branch
- Preserves ordering within each branch
- Each binding retains only its own variables (no alignment)
- Lazy evaluation via `Stream.concat/2`

#### `Executor.union_aligned/2`

UNION with variable alignment:

```elixir
@spec union_aligned(Enumerable.t(), Enumerable.t()) :: binding_stream()
def union_aligned(left, right)
```

- Same concatenation semantics as `union/2`
- Adds `:unbound` marker for missing variables
- Ensures all bindings have the same set of variables
- Useful for projection and serialization

#### `Executor.union_all/1`

Multi-branch UNION:

```elixir
@spec union_all([Enumerable.t()]) :: binding_stream()
def union_all(branches)
```

- Concatenates multiple binding streams in order
- Handles empty list (returns empty stream)
- Handles single branch (returns unchanged)
- Useful for `{ P1 } UNION { P2 } UNION { P3 }` patterns

#### `Executor.collect_all_variables/1`

Variable discovery helper:

```elixir
@spec collect_all_variables(Enumerable.t()) :: MapSet.t(String.t())
def collect_all_variables(bindings)
```

- Returns set of all variable names across all bindings
- Used by `union_aligned/2` for variable alignment

#### `Executor.align_binding/2`

Binding alignment helper:

```elixir
@spec align_binding(binding(), MapSet.t(String.t())) :: binding()
def align_binding(binding, all_vars)
```

- Adds `:unbound` for missing variables
- Preserves existing values
- Used by `union_aligned/2`

### SPARQL Semantics

In SPARQL, `{ P1 } UNION { P2 }` returns:
1. All solutions from P1 (in order)
2. Followed by all solutions from P2 (in order)

Variables not bound in a particular solution are simply absent from that binding (standard SPARQL behavior). The `union_aligned/2` function provides an alternative where missing variables are explicitly marked as `:unbound`.

### Key Design Decisions

1. **Lazy Evaluation**: Uses `Stream.concat/2` for memory-efficient processing
2. **No Implicit Alignment**: `union/2` preserves natural SPARQL semantics
3. **Optional Alignment**: `union_aligned/2` provides aligned variables when needed
4. **Multi-branch Support**: `union_all/1` handles arbitrary number of branches
5. **Unbound Marker**: Uses `:unbound` atom (not `nil`) for explicit missing values

## Test Coverage

27 new tests covering:

### union/2
1. Concatenates two binding streams
2. Preserves order within branches
3. Handles different variables in each branch
4. Handles empty left branch
5. Handles empty right branch
6. Handles both branches empty
7. Works with streams
8. Handles RDF term values

### union_aligned/2
9. Aligns variables across branches
10. Handles completely different variables
11. Handles identical variables
12. Handles empty branches
13. Preserves order within branches

### union_all/1
14. Concatenates multiple branches
15. Handles empty list
16. Handles single branch
17. Preserves order across all branches
18. Handles branches with different variables

### collect_all_variables/1
19. Collects variables from multiple bindings
20. Handles empty bindings list
21. Handles single binding
22. Handles empty binding maps

### align_binding/2
23. Adds missing variables as :unbound
24. Preserves existing values
25. Handles empty binding
26. Handles empty variable set

### Integration
27. Union of two BGP results

## Usage Examples

```elixir
# Basic UNION - concatenate two streams
left = [%{"x" => 1, "y" => "a"}]
right = [%{"x" => 2, "z" => "b"}]
results = Executor.union(left, right) |> Enum.to_list()
# => [%{"x" => 1, "y" => "a"}, %{"x" => 2, "z" => "b"}]

# UNION with variable alignment
results = Executor.union_aligned(left, right) |> Enum.to_list()
# => [
#   %{"x" => 1, "y" => "a", "z" => :unbound},
#   %{"x" => 2, "y" => :unbound, "z" => "b"}
# ]

# Multi-branch UNION
branches = [
  [%{"x" => 1}],
  [%{"x" => 2}],
  [%{"x" => 3}]
]
results = Executor.union_all(branches) |> Enum.to_list()
# => [%{"x" => 1}, %{"x" => 2}, %{"x" => 3}]

# UNION with BGP execution
{:ok, knows_stream} = Executor.execute_bgp(ctx, knows_patterns)
{:ok, likes_stream} = Executor.execute_bgp(ctx, likes_patterns)
results = Executor.union(knows_stream, likes_stream) |> Enum.to_list()
```

## Performance Characteristics

- **union/2**: O(n+m) time, O(1) space - fully lazy
- **union_aligned/2**: O(n+m) time, O(n+m) space - materializes for variable discovery
- **union_all/1**: O(total) time, O(1) space - fully lazy

For most SPARQL queries, `union/2` is preferred as it maintains lazy evaluation.

## Completed Tasks

- [x] 2.4.3.1 Implement `execute_union(db, left, right)` concatenating streams
- [x] 2.4.3.2 Handle variable alignment across branches
- [x] 2.4.3.3 Preserve ordering within branches

## Next Steps

Task 2.4.4: Filter Execution - Execute filter expressions against bindings:
- Implement `execute_filter(stream, expression)` filtering stream
- Implement expression evaluator for all operators
- Handle three-valued logic (true, false, error)
- Implement built-in function evaluation
