# Task 2.5.3: Prepared Queries

## Summary

Implemented prepared query support that caches parsed and optimized query algebra for efficient repeated execution with different parameter bindings. The `prepare/1`, `prepare/2`, and `execute/3` functions provide query compilation and parameterized execution.

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/query.ex` - Added prepared query struct and functions (~350 lines)
- `test/triple_store/sparql/query_test.exs` - Added 27 prepared query tests

### Core Types

#### `Query.Prepared` Struct

```elixir
defmodule Query.Prepared do
  defstruct [
    :sparql,            # Original SPARQL string
    :query_type,        # :select | :ask | :construct | :describe
    :pattern,           # Original algebra pattern
    :optimized_pattern, # Optimized algebra (cached)
    :metadata,          # Query metadata (variables, template, modifiers)
    parameters: []      # List of parameter names extracted from $param syntax
  ]
end
```

### Core Functions

#### `Query.prepare/1` and `Query.prepare/2`

Prepares a SPARQL query for repeated execution:

```elixir
@spec prepare(String.t()) :: {:ok, prepared_query()} | {:error, term()}
@spec prepare(String.t(), prepare_opts()) :: {:ok, prepared_query()} | {:error, term()}
```

Options:
- `:optimize` - Enable/disable optimization (default: true)
- `:stats` - Statistics map for optimizer

#### `Query.execute/3` and `Query.execute/4`

Executes a prepared query with parameter bindings:

```elixir
@spec execute(context(), prepared_query(), params()) :: {:ok, query_result()} | {:error, term()}
@spec execute(context(), prepared_query(), params(), keyword()) :: {:ok, query_result()} | {:error, term()}
```

Options:
- `:timeout` - Maximum execution time in milliseconds (default: 30000)

### Parameter Syntax

Parameters are identified by the `$` prefix in the query string:

```elixir
# Prepare a parameterized query
{:ok, prepared} = Query.prepare("SELECT ?name WHERE { $person foaf:name ?name }")

# Execute with different bindings
{:ok, results1} = Query.execute(ctx, prepared, %{"person" => "http://ex.org/Alice"})
{:ok, results2} = Query.execute(ctx, prepared, %{"person" => "http://ex.org/Bob"})
```

### Parameter Value Types

Parameters can be provided as:

| Value Type | Example | Converts To |
|------------|---------|-------------|
| URI string | `"http://example.org/x"` | `{:named_node, "http://..."}` |
| Plain string | `"Alice"` | `{:literal, :simple, "Alice"}` |
| Integer | `42` | `{:literal, {:typed, "xsd:integer"}, "42"}` |
| Float | `3.14` | `{:literal, {:typed, "xsd:double"}, "3.14"}` |
| Boolean | `true`/`false` | `{:literal, {:typed, "xsd:boolean"}, "..."}` |
| Named node tuple | `{:named_node, "..."}` | Passed through |
| Literal tuple | `{:literal, :simple, "..."}` | Passed through |

### Parameter Substitution

The substitution algorithm recursively traverses the algebra tree:

1. BGP patterns: Substitute in each triple's subject, predicate, object
2. Join/Union/LeftJoin: Recursively substitute in both branches
3. Filter: Substitute in expression and inner pattern
4. Project/Distinct/Reduced: Substitute in inner pattern
5. Expressions: Substitute variables in filter/extend expressions

### Performance Benefits

Prepared queries provide:

1. **Single parse**: Query string is parsed once at prepare time
2. **Single optimize**: Optimization runs once at prepare time
3. **Fast execution**: Only substitution and execution at execute time
4. **Serializable**: Prepared struct can be serialized/stored for later use

## Test Coverage

27 tests covering:

### prepare/1
1. Prepares a simple SELECT query
2. Prepares query with $param parameters
3. Prepares query with multiple parameters
4. Caches both original and optimized pattern
5. Returns error for invalid SPARQL

### prepare/2 with options
6. optimize: false skips optimization
7. stats option passes statistics to optimizer

### prepare!/1
8. Returns prepared query for valid SPARQL
9. Raises for invalid SPARQL

### execute/3
10. Executes prepared query without parameters
11. Executes prepared query with URI parameter
12. Executes prepared query with literal parameter
13. Executes prepared query with named_node tuple parameter
14. Executes prepared query with literal tuple parameter
15. Executes prepared query multiple times efficiently
16. Returns error for missing parameters
17. Extra parameters are ignored

### execute/4 with options
18. Timeout option works

### execute!/3
19. Returns results for valid execution
20. Raises for missing parameters

### Different query types
21. Prepared ASK query
22. Prepared CONSTRUCT query

### Parameter value conversion
23. Integer parameter is converted correctly
24. Boolean parameter is converted correctly
25. Float parameter is converted correctly

### Caching behavior
26. Prepared query struct stores original SPARQL
27. Prepared query can be reused after serialization

## Usage Examples

```elixir
# Prepare a parameterized query
{:ok, prepared} = Query.prepare("""
  SELECT ?name ?age WHERE {
    $person foaf:name ?name .
    $person foaf:age ?age
  }
""")

# Execute multiple times with different parameters
for person <- ["http://ex.org/Alice", "http://ex.org/Bob", "http://ex.org/Carol"] do
  {:ok, results} = Query.execute(ctx, prepared, %{"person" => person})
  IO.inspect(results)
end

# Prepare with optimization disabled
{:ok, prepared} = Query.prepare(sparql, optimize: false)

# Execute with timeout
{:ok, results} = Query.execute(ctx, prepared, params, timeout: 5000)

# Raising variants
prepared = Query.prepare!(sparql)
results = Query.execute!(ctx, prepared, params)

# Serialize for later use
binary = :erlang.term_to_binary(prepared)
File.write!("query.prepared", binary)

# Load and execute later
prepared = :erlang.binary_to_term(File.read!("query.prepared"))
{:ok, results} = Query.execute(ctx, prepared, params)
```

## Comparison: query/2 vs execute/3

| Aspect | query/2 | execute/3 with prepared |
|--------|---------|------------------------|
| Parse | Every call | Once at prepare |
| Optimize | Every call | Once at prepare |
| Parameters | N/A | Substituted at execute |
| Best for | One-off queries | Repeated queries |

## Completed Tasks

- [x] 2.5.3.1 Implement `TripleStore.prepare_query(sparql)` returning prepared query
- [x] 2.5.3.2 Implement `TripleStore.execute(db, prepared, params)` with bindings
- [x] 2.5.3.3 Cache parsed/optimized algebra for prepared queries

## Next Steps

Task 2.5.4: Unit Tests (already included in this implementation)
- Test query returns correct results ✓
- Test query with timeout terminates ✓
- Test streaming query produces all results ✓
- Test streaming query handles early termination ✓
- Test prepared query with parameter binding ✓
- Test prepared query caching ✓

Section 2.6: Aggregation
- Implement GROUP BY execution
- Implement aggregate functions (COUNT, SUM, AVG, MIN, MAX, GROUP_CONCAT)
