# Task 2.4.6: Result Serialization

## Summary

Implemented SPARQL query result serialization for all query types. The executor now supports converting binding streams to SELECT results (list of binding maps), ASK results (boolean), CONSTRUCT results (RDF.Graph from template), and DESCRIBE results (RDF.Graph with Concise Bounded Description).

## Implementation Details

### Files Modified

- `lib/triple_store/sparql/executor.ex` - Added result serialization functions (~330 lines added)
- `test/triple_store/sparql/executor_test.exs` - Added 24 new tests (167 total)

### Core Functions

#### `Executor.to_select_results/2`

Serialize SELECT query results:

```elixir
@spec to_select_results(Enumerable.t(), [String.t()] | nil) :: [binding()]
def to_select_results(stream, vars \\ nil)
```

- Materializes binding stream to list
- Optionally projects to specified variables
- Returns list of binding maps

#### `Executor.to_ask_result/1`

Serialize ASK query results:

```elixir
@spec to_ask_result(Enumerable.t()) :: boolean()
def to_ask_result(stream)
```

- Returns `true` if at least one solution exists
- Returns `false` for empty results
- Short-circuits - only consumes one binding

#### `Executor.to_construct_result/4`

Serialize CONSTRUCT query results:

```elixir
@spec to_construct_result(context(), Enumerable.t(), [tuple()], keyword()) ::
        {:ok, RDF.Graph.t()} | {:error, term()}
def to_construct_result(ctx, stream, template, opts \\ [])
```

- Instantiates template with each binding
- Substitutes variables with bound values
- Skips triples with unbound variables
- Returns RDF.Graph with constructed triples

#### `Executor.to_describe_result/4`

Serialize DESCRIBE query results with CBD:

```elixir
@spec to_describe_result(context(), Enumerable.t(), [String.t()], keyword()) ::
        {:ok, RDF.Graph.t()} | {:error, term()}
def to_describe_result(ctx, stream, vars, opts \\ [])
```

- Collects resources from specified variables
- Fetches all triples where resource is subject
- Optionally follows blank nodes (CBD)
- Returns RDF.Graph with descriptions

### SPARQL Query Type Semantics

| Query Type | Result | Description |
|------------|--------|-------------|
| SELECT | List of bindings | Variable bindings for each solution |
| ASK | Boolean | Whether any solution exists |
| CONSTRUCT | RDF.Graph | New graph from template instantiation |
| DESCRIBE | RDF.Graph | CBD of selected resources |

### Concise Bounded Description (CBD)

DESCRIBE implements CBD which includes:
1. All triples where the resource is subject
2. Recursively, CBD of any blank nodes appearing as objects

This ensures that blank node structures are fully described.

### Key Design Decisions

1. **SELECT Materialization**: `to_select_results/2` fully materializes the stream
2. **ASK Short-Circuit**: Only reads one binding for efficiency
3. **Template Instantiation**: Variables substituted, unbound values skip triple
4. **CBD for DESCRIBE**: Follows blank nodes to complete the description
5. **RDF.ex Integration**: Results use RDF.Graph for standard compatibility

### Helper Functions

- `instantiate_template/2` - Substitute bindings into template patterns
- `substitute_term/2` - Resolve variable or pass through concrete term
- `build_graph_from_terms/3` - Convert internal terms to RDF.Graph
- `internal_to_rdf/1` - Convert internal tuple representation to RDF.ex terms
- `describe_resources/4` - Fetch CBD for resources
- `resource_to_id/2` - Convert internal term to dictionary ID
- `follow_blank_nodes/3` - Recursively fetch blank node descriptions

## Test Coverage

24 new tests covering:

### to_select_results/2
1. Converts stream to list of bindings
2. Projects specified variables
3. Handles empty stream
4. Handles RDF term values
5. Works with lazy streams

### to_ask_result/1
6. Returns true when solutions exist
7. Returns false when no solutions exist
8. Returns true with multiple solutions
9. Works with lazy streams (short-circuits)
10. Handles empty binding (unit stream)

### to_construct_result/4
11. Builds graph from template with bindings
12. Skips triples with unbound variables
13. Handles concrete terms in template
14. Handles empty bindings
15. Handles typed literals
16. Handles language-tagged literals

### to_describe_result/4
17. Describes resources from bindings
18. Describes multiple resources
19. Handles empty bindings
20. Handles unbound variable
21. Handles nonexistent resource

### Integration
22. SELECT with BGP execution
23. ASK with BGP execution
24. CONSTRUCT with BGP execution

## Usage Examples

```elixir
# SELECT - get all names
{:ok, stream} = Executor.execute_bgp(ctx, [
  {:triple, {:variable, "s"}, {:named_node, "http://ex.org/name"}, {:variable, "name"}}
])
results = Executor.to_select_results(stream, ["name"])
# => [%{"name" => {:literal, :simple, "Alice"}}, %{"name" => {:literal, :simple, "Bob"}}]

# ASK - check if Alice exists
{:ok, stream} = Executor.execute_bgp(ctx, [
  {:triple, {:named_node, "http://ex.org/Alice"}, {:variable, "p"}, {:variable, "o"}}
])
exists = Executor.to_ask_result(stream)
# => true

# CONSTRUCT - transform predicates
{:ok, stream} = Executor.execute_bgp(ctx, patterns)
template = [
  {:triple, {:variable, "s"}, {:named_node, "http://xmlns.com/foaf/0.1/name"}, {:variable, "name"}}
]
{:ok, graph} = Executor.to_construct_result(ctx, stream, template)

# DESCRIBE - get CBD for selected resources
{:ok, stream} = Executor.execute_bgp(ctx, [
  {:triple, {:variable, "person"}, {:named_node, "http://ex.org/type"}, {:named_node, "http://ex.org/Person"}}
])
{:ok, graph} = Executor.to_describe_result(ctx, stream, ["person"])
```

## Performance Characteristics

| Function | Time | Space | Notes |
|----------|------|-------|-------|
| to_select_results/2 | O(n) | O(n) | Full materialization |
| to_ask_result/1 | O(1) | O(1) | Short-circuits |
| to_construct_result/4 | O(n*t) | O(n*t) | n bindings, t template size |
| to_describe_result/4 | O(n*d) | O(n*d) | n resources, d triples per resource |

## Completed Tasks

- [x] 2.4.6.1 Implement SELECT result as list of binding maps
- [x] 2.4.6.2 Implement CONSTRUCT result as `RDF.Graph`
- [x] 2.4.6.3 Implement ASK result as boolean
- [x] 2.4.6.4 Implement DESCRIBE result as `RDF.Graph` with CBD

## Next Steps

Task 2.4.7: Unit Tests - This was integrated into each task already. The executor module now has comprehensive test coverage with 167 tests.

Following that, Phase 2.5: Query Integration - Wire together all components into the public API.
